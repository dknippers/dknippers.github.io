{"version":3,"sources":["svg/clockwise.svg","svg/counter-clockwise.svg","img/fiene.png","helpers/index.js","selectors/playerSelectors.js","constants/index.js","selectors/cellSelectors.js","actions/ai.js","actions/options.js","actions/game.js","actions/localStorage.js","reducers/cellsReducer.js","components/Cell.js","components/Arrow.js","components/Quadrant.js","components/Board.js","components/Controls.js","components/ErrorMessage.js","components/StatusMessage.js","components/Options.js","components/Score.js","components/Game.js","components/DevTools.js","components/Pentago.js","reducers/playersReducer.js","reducers/uiReducer.js","reducers/optionsReducer.js","reducers/rootReducer.js","registerServiceWorker.js","index.js","store/buildStore.js"],"names":["module","exports","__webpack_require__","p","byId","array","reduce","element","id","chunk","func","keepNullOrUndefined","arguments","length","undefined","Array","isArray","Error","chunks","_ref","_ref2","Object","slicedToArray","prevValue","prevElements","newValue","push","filter","groupBy","grouped","key","greaterThan","x","y","minOrMax","operator","compareBy","transform","_array$reduce","mmData","mmValue","value","max","maxElement","transpose","some","subArray","maxColSize","maxBy","maxValue","transposed","col","row","getPlayersById","state","players","getActivePlayerId","activePlayer","getPlayers","createSelector","playersById","keys","map","getActivePlayer","activePlayerId","getNextPlayer","nextPlayerId","activePlayerIsAI","player","isAI","AMOUNT_IN_LINE_TO_WIN","BOARD_SIZE","QUADRANT_SIZE","NUM_QUADRANTS","Math","floor","colors","forEach","hue","randomColor","luminosity","COLORS","getCells","cells","cellsById","getCell","getAvailableCells","cell","getSortedCells","sort","getRows","rows","getColumns","columns","getDiagonals","diagonals","collectionOfDiagonals","_i","_Object$keys","diagonal","findWinningCellsInLines","lines","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","winningCells","winsInLine","err","return","getWinningCellsByPlayer","winningCellsByPlayer","concat","toConsumableArray","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","line","find","Constants","quadrantMinAndMaxRowOrCol","rowOrCol","quadrantMinAndMaxRow","quadrantMinAndMaxCol","getQuadrant","_quadrantMinAndMaxRow","_quadrantMinAndMaxRow2","minRow","maxRow","_quadrantMinAndMaxCol","_quadrantMinAndMaxCol2","minCol","maxCol","getQuadrants","quadrants","r","c","getQuadrants2D","rotate","quadrant","turnClockwise","reverse","makeGetRotatedQuadrant","column","clockwise","makeGetQuadrant","rotated","_quadrantMinAndMaxRow3","_quadrantMinAndMaxCol3","irow","icol","assign","getMetadata","cellsInLine","metadata","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","potentials","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","potentialAmountInLine","computePotentialsInLine","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","group","maxAdjacentsInLine","groups","_chunk","isEmpty","firstCell","firstIdx","indexOf","lastCell","isLastAndEmpty","prevGroup","prevGroupIsEmpty","every","prevLastCell","prevLastIdx","abs","pop","emptyIdx","findIndex","slice","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","scoreForPlayer","scoreSystemPotentials","2","3","4","5","6","fillQuadrantMultiplier","noFriendliesAround","score","points","wins","k","parseInt","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","n","base","chunkedCells","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_loop","multiplier","emptyCell","qSize","surroundingCells","getSurroundingCells","quadrantOfEmptyCell","getQuadrantId","_iterator9","scoreSystemCells","cellQuadrantId","missingCells","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","otherCell","possibleCell","getBoardScoreByPlayer","playerScores","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","playerOne","playerTwo","playerOnePoints","playerOneWins","playerTwoPoints","playerTwoWins","defineProperty","pointsOne","pointsTwo","qRow","qCol","currentPlayer","nextPlayer","boards","computeMove","showMove","dispatch","getState","gameOver","cellId","rotation","initBoard","_arr","getBoards","moveData","canPickCell","optimalMovesInOrder","moveFunction","optimalRotation","type","COMPUTED_MOVE","move","HIDE_COMPUTED_MOVE","computeAndDoMove","ui","computedMove","tryPickCell","options","animationsEnabled","animateQuadrant","rotateQuadrant","rotatedCells","newState","computeMetadata","winningMove","doAsPlayer","boardsToConsider","board","preventWithOptimalRotation","_ref7$player","makeLine","requiresFullQuadrant","makeLine4","getBoard","centers","q","playerCenters","center","availableCenters","cc","random","min","_ref2$player","_ref2$doAsPlayer","_ref2$min","_ref2$requiresFullQua","_ref2$requiresRotatio","requiresRotation","_ref2$boardsToConside","optimal","lookahead","meta","newMeta","_i2","_keys","_loop2","groupOfEmptyCell","a","j","i","newA","from","shuffle","_ref3","_ref3$player","_ref3$boardsToConside","_ref3$lookahead","_ref5$player","boardsWithRotation","SET_PLAYER_NAME","SET_PLAYER_AI","TOGGLE_OPTIONS","toggleOptions","SET_AI_MOVE_DELAY","SET_AUTOMATIC_RESTART","SET_ANIMATIONS_ENABLED","SET_ANIMATION_DURATION","SET_SHOW_LOAD_SAVE_BUTTONS","SET_FIENE_MODE","playerId","errorMessage","validateMove","SHOW_ERROR","error","color","PICK_CELL","pickCell","cellColor","fieneMode","_getQuadrantRowAndCol","getQuadrantRowAndColumn","updateScores","checkWinner","isDraw","winners","winner","WINNING_CELLS","PLAYER_WON","playerWon","automaticRestart","setTimeout","restartGame","DRAW","RESTART_GAME","beginTurn","SELECT_QUADRANT","ANIMATE_QUADRANT","animationDuration","ROTATE_QUADRANT","rotateQuadrantAction","winningRotation","HIDE_ERROR","BEGIN_TURN","timeout","aiMoveDelay","UPDATE_SCORES","scores","SHOW_LAST_MOVE","HIDE_LAST_MOVE","SAVE_TO_STORAGE","LOAD_FROM_STORAGE","CLEAR_STORAGE","connect","props","lastMove","isEnabled","showLastMove","draw","canRotateQuadrant","isWinningCell","isComputedByAi","react_default","createElement","style","animationDurationInSeconds","transition","backgroundColor","getStyle","className","classNames","join","getClassNames","onClick","makeArrow","aiRotation","lastRotation","isSelected","dangerouslySetInnerHTML","isSameRotation","e","stopPropagation","hasSelectedQuadrant","selectedQuadrant","quadrantAnimation","selectQuadrant","isThisQuadrant","components_Cell","react_inlinesvg_es","wrapper","apply","getArrowParams","src","counterClockwise","quadrantObject","disableCells","isAnimating","enableQuadrants","quadrantRow","components_Quadrant","hasPreviousMove","showingLastMove","showingOptions","showOptions","hasComputedMove","showAIButtons","disableAIButtons","gameStarted","hasStoredState","showLoadSaveButtons","hideComputedMove","hideLastMove","saveToStorage","window","localStorage","JSON","stringify","loadFromStorage","clearStorage","removeItem","disabled","fiene","alt","name","isVisible","setPlayerName","setPlayerAI","setAIMoveDelay","setAutomaticRestart","enabled","setAnimationsEnabled","setAnimationDuration","duration","setShowLoadSaveButtons","show","setFieneMode","on","player1","player2","htmlFor","onChange","target","checked","defaultValue","onBlur","boardScores","components_StatusMessage","components_Board","components_Score","components_Controls","components_ErrorMessage","components_Options","createDevTools","redux_devtools_dock_monitor_lib_default","toggleVisibilityKey","changePositionKey","redux_devtools_log_monitor_lib_default","Pentago","components_Game","allCells","initialState","action","rotatedQuadrant","uiReducer","combineReducers","optionsReducer","isNaN","rootReducer","cellsReducer","reducers_rootReducer","stored","parse","Boolean","location","hostname","match","store","createStore","compose","applyMiddleware","thunk","DevTools","instrument","ReactDOM","render","es","components_Pentago","document","getElementById"],"mappings":"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","file":"static/js/main.7c2df92b.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/clockwise.942198c7.svg\";","module.exports = __webpack_public_path__ + \"static/media/counter-clockwise.d21e64eb.svg\";","module.exports = __webpack_public_path__ + \"static/media/fiene.bd1a0420.png\";","export function byId(array) {\r\n    return array.reduce(\r\n        (byId, element) => (byId[element.id] = element) && byId,\r\n        {}\r\n    );\r\n}\r\n\r\n// Ruby's Array#chunk\r\nexport function chunk(array, func, keepNullOrUndefined = false) {\r\n    if (!Array.isArray(array)) {\r\n        throw new Error(`First argument should be an Array`);\r\n    }\r\n\r\n    if (typeof func !== \"function\") {\r\n        throw new Error(`Second argument should be a Function`);\r\n    }\r\n\r\n    const chunks = array.reduce((chunks, element) => {\r\n        const prev = chunks[chunks.length - 1];\r\n        const [prevValue, prevElements] = prev || [];\r\n\r\n        const newValue = func(element);\r\n\r\n        if (newValue !== prevValue) {\r\n            // This will become a new element\r\n            chunks.push([newValue, [element]]);\r\n        } else {\r\n            // Add to previous\r\n            prevElements.push(element);\r\n        }\r\n\r\n        return chunks;\r\n    }, []);\r\n\r\n    // Filter out any elements of a null or undefined key,\r\n    // unless specified otherwise\r\n    if (keepNullOrUndefined) return chunks;\r\n\r\n    return chunks.filter(chunk => chunk[0] != null);\r\n}\r\n\r\nexport function groupBy(array, func) {\r\n    return array.reduce((grouped, element) => {\r\n        const key = func(element);\r\n        (grouped[key] || (grouped[key] = [])).push(element);\r\n        return grouped;\r\n    }, {});\r\n}\r\n\r\n// Ruby's Array#uniq\r\nexport function uniq(array) {\r\n    return array.reduce((uniques, element) => {\r\n        if (uniques.indexOf(element) === -1) {\r\n            uniques.push(element);\r\n        }\r\n\r\n        return uniques;\r\n    }, []);\r\n}\r\n\r\n// From: http://stackoverflow.com/a/6274381/2858155\r\n// Modified to return new array\r\nexport function shuffle(a) {\r\n    const newA = Array.from(a);\r\n\r\n    var j, x, i;\r\n    for (i = newA.length; i; i--) {\r\n        j = Math.floor(Math.random() * i);\r\n        x = newA[i - 1];\r\n        newA[i - 1] = newA[j];\r\n        newA[j] = x;\r\n    }\r\n\r\n    return newA;\r\n}\r\n\r\nfunction greaterThan(x, y) {\r\n    if (x > y) return 1;\r\n    if (x < y) return -1;\r\n    return 0;\r\n}\r\n\r\nfunction lessThan(x, y) {\r\n    return greaterThan(y, x);\r\n}\r\n\r\nfunction minOrMax(array, operator, compareBy = x => x, transform = x => x) {\r\n    const [mmElement] = array.reduce(\r\n        (mmData, element) => {\r\n            const [, mmValue] = mmData;\r\n            const value = compareBy(element);\r\n\r\n            if (value == null) return mmData;\r\n\r\n            if (mmValue == null || operator(value, mmValue) > 0) {\r\n                return [element, value];\r\n            }\r\n\r\n            return mmData;\r\n        },\r\n        [null, null]\r\n    ); // <= [ mmElement, mmValue ]\r\n\r\n    return transform(mmElement);\r\n}\r\n\r\nfunction max(array, compareBy = x => x, transform = x => x) {\r\n    return minOrMax(array, greaterThan, compareBy, transform);\r\n}\r\n\r\nfunction min(array, compareBy = x => x, transform = x => x) {\r\n    return minOrMax(array, lessThan, compareBy, transform);\r\n}\r\n\r\n// Returns the maximum element, comparing the property obtained\r\n// from calling `maxBy` on each element.\r\nexport function maxElement(array, maxBy = x => x) {\r\n    return max(array, maxBy);\r\n}\r\n\r\n// Returns the maximum value, comparing the property obtained\r\n// from calling `maxBy` on each element returning the maximum\r\n// resulting value\r\nexport function maxValue(array, maxBy) {\r\n    return max(array, maxBy, maxBy);\r\n}\r\n\r\n// Returns the minimum element, comparing the property obtained\r\n// from calling `minBy` on each element.\r\nexport function minElement(array, minBy = x => x) {\r\n    return min(array, minBy);\r\n}\r\n\r\n// Returns the minimum value, comparing the property obtained\r\n// from calling `minBy` on each element returning the minimum\r\n// resulting value\r\nexport function minValue(array, minBy = x => x) {\r\n    return min(array, minBy, minBy);\r\n}\r\n\r\nexport function transpose(array) {\r\n    if (\r\n        !Array.isArray(array) ||\r\n        array.length === 0 ||\r\n        array.some(subArray => !Array.isArray(subArray))\r\n    ) {\r\n        throw new Error(\r\n            `Argument should be an Array of exclusively other Arrays`\r\n        );\r\n    }\r\n\r\n    const maxColSize = maxValue(array, subArray => subArray.length);\r\n\r\n    const transposed = [];\r\n\r\n    for (let col = 0; col < maxColSize; col++) {\r\n        for (let row = 0; row < array.length; row++) {\r\n            (transposed[col] || (transposed[col] = []))[row] = array[row][col];\r\n        }\r\n    }\r\n\r\n    return transposed;\r\n}\r\n","import { createSelector } from \"reselect\";\r\n\r\nexport const getPlayersById = state => state.players;\r\nexport const getActivePlayerId = state => state.activePlayer;\r\nexport const getNextPlayerId = state => state.activePlayer % 2 + 1;\r\n\r\nexport const getPlayers = createSelector(getPlayersById, playersById =>\r\n    Object.keys(playersById).map(id => playersById[id])\r\n);\r\n\r\nexport const getPlayer = playerId =>\r\n    createSelector(getPlayersById, playersById => playersById[playerId]);\r\n\r\nexport const getActivePlayer = createSelector(\r\n    getPlayersById,\r\n    getActivePlayerId,\r\n    (playersById, activePlayerId) => playersById[activePlayerId]\r\n);\r\n\r\nexport const getNextPlayer = createSelector(\r\n    getPlayersById,\r\n    getNextPlayerId,\r\n    (playersById, nextPlayerId) => playersById[nextPlayerId]\r\n);\r\n\r\nexport const getOtherPlayer = playerId =>\r\n    createSelector(\r\n        getPlayersById,\r\n        playersById =>\r\n            playersById[\r\n                Object.keys(playersById).find(k => parseInt(k, 10) !== playerId)\r\n            ]\r\n    );\r\n\r\nexport const activePlayerIsAI = createSelector(\r\n    getActivePlayer,\r\n    player => player.isAI\r\n);\r\n","import randomColor from \"randomcolor\";\r\n\r\nexport const AMOUNT_IN_LINE_TO_WIN = 5;\r\nexport const BOARD_SIZE = 6;\r\nexport const QUADRANT_SIZE = 3;\r\nexport const NUM_QUADRANTS = Math.floor(BOARD_SIZE / QUADRANT_SIZE, 10);\r\n\r\nconst colors = [];\r\nconst hues = [\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"purple\", \"pink\"];\r\nhues.forEach(hue => colors.push(randomColor({ hue, luminosity: \"bright\" })));\r\n\r\nexport const COLORS = colors;\r\n","import { createSelector } from \"reselect\";\r\nimport { chunk, transpose, groupBy } from \"../helpers\";\r\nimport { getPlayers } from \"./playerSelectors\";\r\nimport * as Constants from \"../constants\";\r\n\r\n// The input for all other selectors, make sure this *only* yields\r\n// a new object when the relevant state has actually changed\r\nconst initCells = state => state.cells;\r\n\r\nconst getCells = createSelector(initCells, cellsById =>\r\n    Object.keys(cellsById).map(id => cellsById[id])\r\n);\r\n\r\nexport const getCell = (state, id) => state.cells[id];\r\n\r\nexport const getAvailableCells = createSelector(getCells, cells =>\r\n    cells.filter(cell => cell.player == null)\r\n);\r\n\r\nconst getSortedCells = createSelector(getCells, cells => {\r\n    return cells.sort((x, y) => {\r\n        if (x.row > y.row) return 1;\r\n        if (x.row < y.row) return -1;\r\n\r\n        if (x.col > y.col) return 1;\r\n        if (x.col < y.col) return -1;\r\n\r\n        return 0;\r\n    });\r\n});\r\n\r\nexport const getRows = createSelector(getSortedCells, cells =>\r\n    cells.reduce(\r\n        (rows, cell) =>\r\n            (rows[cell.row] || (rows[cell.row] = [])).push(cell) && rows,\r\n        []\r\n    )\r\n);\r\n\r\nexport const getColumns = createSelector(getSortedCells, cells =>\r\n    cells.reduce(\r\n        (columns, cell) =>\r\n            (columns[cell.col] || (columns[cell.col] = [])).push(cell) &&\r\n            columns,\r\n        []\r\n    )\r\n);\r\n\r\nexport const getDiagonals = createSelector(getSortedCells, cells => {\r\n    const topLeftToBottomRight = groupBy(cells, cell => cell.row - cell.col);\r\n    const bottomLeftToTopRight = groupBy(cells, cell => cell.row + cell.col);\r\n\r\n    return [\r\n        topLeftToBottomRight,\r\n        bottomLeftToTopRight\r\n    ].reduce((diagonals, collectionOfDiagonals) => {\r\n        for (let key of Object.keys(collectionOfDiagonals)) {\r\n            const diagonal = collectionOfDiagonals[key];\r\n            diagonals.push(diagonal);\r\n        }\r\n        return diagonals;\r\n    }, []);\r\n});\r\n\r\nfunction findWinningCellsInLines(lines, player) {\r\n    if (!player) return null;\r\n\r\n    for (let line of lines) {\r\n        const winningCells = winsInLine(line, player);\r\n        if (winningCells) return winningCells;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport const getWinningCellsByPlayer = createSelector(\r\n    getRows,\r\n    getColumns,\r\n    getDiagonals,\r\n    getPlayers,\r\n    (rows, columns, diagonals, players) => {\r\n        const winningCellsByPlayer = {};\r\n\r\n        const lines = [...rows, ...columns, ...diagonals];\r\n\r\n        for (let player of players) {\r\n            winningCellsByPlayer[player.id] = findWinningCellsInLines(\r\n                lines,\r\n                player.id\r\n            );\r\n        }\r\n\r\n        return winningCellsByPlayer;\r\n    }\r\n);\r\n\r\nfunction winsInLine(line, player) {\r\n    return chunk(line, cell => cell.player === player)\r\n        .filter(chunk => chunk[0])\r\n        .map(chunk => chunk[1])\r\n        .find(cells => cells.length >= Constants.AMOUNT_IN_LINE_TO_WIN);\r\n}\r\n\r\nconst quadrantMinAndMaxRowOrCol = rowOrCol => [\r\n    rowOrCol * Constants.QUADRANT_SIZE,\r\n    (rowOrCol + 1) * Constants.QUADRANT_SIZE - 1\r\n];\r\n\r\nconst quadrantMinAndMaxRow = row => quadrantMinAndMaxRowOrCol(row);\r\nconst quadrantMinAndMaxCol = col => quadrantMinAndMaxRowOrCol(col);\r\n\r\nfunction getQuadrant(row, col, cells) {\r\n    const [minRow, maxRow] = quadrantMinAndMaxRow(row);\r\n    const [minCol, maxCol] = quadrantMinAndMaxCol(col);\r\n\r\n    const cellsOfQuadrant = cells.filter(\r\n        cell =>\r\n            cell.row >= minRow &&\r\n            cell.row <= maxRow &&\r\n            cell.col >= minCol &&\r\n            cell.col <= maxCol\r\n    );\r\n\r\n    return chunk(cellsOfQuadrant, cell => cell.row).map(chunk => chunk[1]);\r\n}\r\n\r\nexport const makeGetQuadrant = (row, col) =>\r\n    createSelector(getSortedCells, cells => getQuadrant(row, col, cells));\r\n\r\n// Returns the quadrants in an Array\r\nexport const getQuadrants = createSelector(getSortedCells, cells => {\r\n    const quadrants = [];\r\n\r\n    for (let r = 0; r < Constants.NUM_QUADRANTS; r++) {\r\n        for (let c = 0; c < Constants.NUM_QUADRANTS; c++) {\r\n            quadrants.push(getQuadrant(r, c, cells));\r\n        }\r\n    }\r\n\r\n    return quadrants;\r\n});\r\n\r\n// Returns the quadrants in a 2D Array (i.e., in rows and columns)\r\nexport const getQuadrants2D = createSelector(getSortedCells, cells => {\r\n    const quadrants = [];\r\n\r\n    for (let r = 0; r < Constants.NUM_QUADRANTS; r++) {\r\n        const row = [];\r\n\r\n        for (let c = 0; c < Constants.NUM_QUADRANTS; c++) {\r\n            row.push(getQuadrant(r, c, cells));\r\n        }\r\n\r\n        quadrants.push(row);\r\n    }\r\n\r\n    return quadrants;\r\n});\r\n\r\nfunction rotateClockwise(quadrant) {\r\n    return transpose(quadrant.reverse());\r\n}\r\n\r\nfunction rotateCounterclockwise(quadrant) {\r\n    return transpose(quadrant.map(row => row.reverse()));\r\n}\r\n\r\nfunction rotate(quadrant, turnClockwise) {\r\n    return (turnClockwise ? rotateClockwise : rotateCounterclockwise)(quadrant);\r\n}\r\n\r\n// Returns copied cells, does not actually modify the cells of this state\r\nexport const makeGetRotatedQuadrant = (row, column, clockwise) =>\r\n    createSelector(makeGetQuadrant(row, column), quadrant => {\r\n        // Apply rotation\r\n        const rotated = rotate(quadrant, clockwise);\r\n\r\n        const [minRow] = quadrantMinAndMaxRow(row);\r\n        const [minCol] = quadrantMinAndMaxCol(column);\r\n\r\n        // Return a flat object of cell id => cell,\r\n        // where we have updated .row and .col of each cell\r\n        // accordingly to its new position in the quadrant\r\n        // which is currently only represented by the index\r\n        const cells = {};\r\n\r\n        for (let irow = 0; irow < rotated.length; irow++) {\r\n            const row = rotated[irow];\r\n            for (let icol = 0; icol < row.length; icol++) {\r\n                const cell = rotated[irow][icol];\r\n\r\n                cells[cell.id] = Object.assign({}, cell, {\r\n                    row: irow + minRow,\r\n                    col: icol + minCol\r\n                });\r\n            }\r\n        }\r\n\r\n        return cells;\r\n    });\r\n\r\nexport const getMetadata = createSelector(\r\n    getPlayers,\r\n    getRows,\r\n    getColumns,\r\n    getDiagonals,\r\n    (players, rows, columns, diagonals) => {\r\n        const cellsInLine = [...rows, ...columns, ...diagonals];\r\n        const metadata = {};\r\n\r\n        for (let player of players) {\r\n            const potentials = {};\r\n\r\n            for (let line of cellsInLine) {\r\n                const potentialAmountInLine = computePotentialsInLine(\r\n                    line,\r\n                    player\r\n                );\r\n                if (\r\n                    !potentialAmountInLine ||\r\n                    potentialAmountInLine.length === 0\r\n                )\r\n                    continue;\r\n\r\n                for (let group of potentialAmountInLine) {\r\n                    (potentials[group.length] ||\r\n                        (potentials[group.length] = []))\r\n                        .push(group);\r\n                }\r\n            }\r\n\r\n            metadata[player.id] = potentials;\r\n        }\r\n\r\n        return metadata;\r\n    }\r\n);\r\n\r\nfunction computePotentialsInLine(line, player) {\r\n    const maxInLine = maxAdjacentsInLine(line, player);\r\n    // If the maximum amount is not enough to win\r\n    // there's no potential whatsoever, line should be totally ignored.\r\n    if (maxInLine < Constants.AMOUNT_IN_LINE_TO_WIN) return null;\r\n\r\n    // Chunk by empty or owned by player, drops opponents cells\r\n    const chunks = chunk(\r\n        line,\r\n        cell =>\r\n            cell.player == null || (cell.player === player.id ? false : null)\r\n    );\r\n\r\n    return chunks.reduce((groups, chunk) => {\r\n        const [isEmpty, cells] = chunk;\r\n\r\n        // TODO: Fix this can occur at all (bug in chunk method when last element becomes null)\r\n        // if(!cells) return groups;\r\n\r\n        const firstCell = cells[0];\r\n        const firstIdx = line.indexOf(firstCell);\r\n        const lastCell = cells[cells.length - 1];\r\n\r\n        const isLastAndEmpty =\r\n            isEmpty && chunks.indexOf(chunk) === chunks.length - 1;\r\n\r\n        const prevGroup = groups[groups.length - 1];\r\n\r\n        // No previous group, add yourself and be done\r\n        if (!prevGroup) {\r\n            if (!isLastAndEmpty) {\r\n                groups.push(cells);\r\n            }\r\n        } else {\r\n            const prevGroupIsEmpty = prevGroup.every(\r\n                cell => cell.player == null\r\n            );\r\n            let prevLastCell = prevGroup[prevGroup.length - 1];\r\n            let prevLastIdx = line.indexOf(prevLastCell);\r\n\r\n            let distance = Math.abs(firstIdx - prevLastIdx);\r\n\r\n            // If we are not adjacent, we can't join them\r\n            if (distance > 1) {\r\n                // However, make sure to remove the previous group\r\n                // if it was completely empty\r\n                if (prevGroupIsEmpty) {\r\n                    groups.pop();\r\n                }\r\n\r\n                // And add ourself so other cells can join up later\r\n                if (!isLastAndEmpty) {\r\n                    groups.push(cells);\r\n                }\r\n            } else {\r\n                // Empty cells, first cell will try to join the previous group\r\n                if (isEmpty) {\r\n                    // If the previous group is completely empty, remove it (it's irrelevant)\r\n                    if (prevGroupIsEmpty) {\r\n                        groups.pop();\r\n\r\n                        // Add ourselves, but not if we are the last empty group\r\n                        if (!isLastAndEmpty) {\r\n                            groups.push(cells);\r\n                        }\r\n                    } else {\r\n                        // This group belongs to the player, we join it with our first cell,\r\n                        // _only if_ it does not have an empty cell yet\r\n                        if (!prevGroup.some(cell => cell.player == null)) {\r\n                            // Cool, let's join them\r\n                            prevGroup.push(firstCell);\r\n                        } else {\r\n                            // It already has merged with some other empty cell\r\n                            // We instead duplicate it and create a new group\r\n                            // First we drop all cells upto the empty cell and then the empty cell itself\r\n                            const emptyIdx = prevGroup.findIndex(\r\n                                cell => cell.player == null\r\n                            );\r\n                            groups.push([\r\n                                ...prevGroup.slice(emptyIdx + 1),\r\n                                firstCell\r\n                            ]);\r\n                        }\r\n\r\n                        // We only add ourselves when firstCell is different from lastCell\r\n                        // If firstCell is the same as lastCell, the next group can just join\r\n                        // us in the previous group.\r\n                        // Again, do not add ourselves if we are the last group and empty\r\n                        if (firstCell !== lastCell && !isLastAndEmpty) {\r\n                            groups.push(cells);\r\n                        }\r\n                    }\r\n                } else {\r\n                    // Player controlled cells\r\n                    // Try to join a previous player-controlled group\r\n                    // It can have most have 1 empty cell but that's fine\r\n                    if (prevGroup.some(cell => cell.player != null)) {\r\n                        for (let cell of cells) {\r\n                            prevGroup.push(cell);\r\n                        }\r\n                    } else {\r\n                        // Previous group is entirely empty\r\n                        // Grab their last cell and put it in a new group,\r\n                        // remove the empty group\r\n                        groups.pop();\r\n                        groups.push([prevLastCell, ...cells]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return groups;\r\n    }, []);\r\n}\r\n\r\nfunction maxAdjacentsInLine(line, player) {\r\n    // Chunk line into Arrays containing adjacent spots\r\n    // that are empty or belong to player\r\n    const chunks = chunk(\r\n        line,\r\n        cell => (cell.player != null && cell.player !== player.id ? null : true)\r\n    );\r\n    return chunks\r\n        .map(chunk => chunk[1])\r\n        .reduce(\r\n            (max, chunk) => (chunk && chunk.length > max ? chunk.length : max),\r\n            0\r\n        );\r\n}\r\n\r\nfunction scoreForPlayer(rows, metadata, player) {\r\n    const scoreSystemPotentials = {\r\n        2: 1,\r\n        3: 10,\r\n        4: 100,\r\n        5: 1000,\r\n        6: 10000,\r\n\r\n        fillQuadrantMultiplier: 4,\r\n        noFriendliesAround: 0.25\r\n    };\r\n\r\n    const score = {\r\n        points: 0,\r\n        wins: false\r\n    };\r\n\r\n    // Score for potential cells in a line\r\n    const keys = Object.keys(metadata[player.id]).map(k => parseInt(k, 10));\r\n    for (let n of keys) {\r\n        let base = scoreSystemPotentials[n];\r\n\r\n        const chunkedCells = metadata[player.id][n];\r\n\r\n        for (let group of chunkedCells) {\r\n            let multiplier = 1;\r\n\r\n            const emptyCell = group.find(cell => cell.player == null);\r\n\r\n            // No emptyCell means it's not a potential of n, but it already IS n,\r\n            // the line is simply not longer. So increase our base accordingly.\r\n            if (!emptyCell) {\r\n                base = scoreSystemPotentials[n + 1];\r\n            } else {\r\n                const qSize = Constants.QUADRANT_SIZE;\r\n                const cellsByQuadrant = chunk(\r\n                    group,\r\n                    cell =>\r\n                        `${Math.floor(cell.row / qSize)}${Math.floor(\r\n                            cell.col / qSize\r\n                        )}`\r\n                ).map(chunk => chunk[1]);\r\n\r\n                // Empty cell completed a quadrant if the group it is part of is the length of a quadrant\r\n                const groupOfEmptyCell = cellsByQuadrant.find(\r\n                    cells => cells.indexOf(emptyCell) > -1\r\n                );\r\n                const completesQuadrant =\r\n                    groupOfEmptyCell.length === Constants.QUADRANT_SIZE;\r\n\r\n                if (completesQuadrant) {\r\n                    multiplier *= scoreSystemPotentials.fillQuadrantMultiplier;\r\n                }\r\n\r\n                // If the empty cell is not surrounded by any friendly cells in its quadrant,\r\n                // impose a big penalty (experimental)\r\n                const surroundingCells = getSurroundingCells(emptyCell, rows);\r\n                const quadrantOfEmptyCell = getQuadrantId(emptyCell);\r\n                if (\r\n                    !surroundingCells.some(\r\n                        cell =>\r\n                            getQuadrantId(cell) === quadrantOfEmptyCell &&\r\n                            cell.player === player.id\r\n                    )\r\n                ) {\r\n                    multiplier *= scoreSystemPotentials.noFriendliesAround;\r\n                }\r\n            }\r\n\r\n            score.points += base * multiplier;\r\n\r\n            // If n > AMOUNT_TO_WIN, we have actually already won ;)\r\n            if (\r\n                n > Constants.AMOUNT_IN_LINE_TO_WIN ||\r\n                (n === Constants.AMOUNT_IN_LINE_TO_WIN && !emptyCell)\r\n            ) {\r\n                score.wins = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Score for individual cells\r\n    const scoreSystemCells = {\r\n        none: -1, // Cells at the edge\r\n        opponent: 0,\r\n        empty: 1,\r\n        mine: 4,\r\n        sameQuadrantMultiplier: 1.5\r\n    };\r\n\r\n    for (let r = 0; r < rows.length; r++) {\r\n        const row = rows[r];\r\n\r\n        for (let c = 0; c < row.length; c++) {\r\n            const cell = row[c];\r\n\r\n            // Only score my cells\r\n            if (cell.player == null || cell.player !== player.id) continue;\r\n\r\n            const cellQuadrantId = getQuadrantId(cell);\r\n            const surroundingCells = getSurroundingCells(cell, rows);\r\n\r\n            // A cell has at most (QUADRANT_SIZE ^ 2) - 1 surrounding cells\r\n            // Any missing cell will score scoreSystemCells.none points\r\n            const missingCells =\r\n                Constants.QUADRANT_SIZE * Constants.QUADRANT_SIZE -\r\n                surroundingCells.length;\r\n            score.points += missingCells * scoreSystemCells.none;\r\n\r\n            for (let otherCell of surroundingCells) {\r\n                const otherCellQuadrantId = getQuadrantId(otherCell);\r\n                const isSameQuadrant = cellQuadrantId === otherCellQuadrantId;\r\n                const multiplier = isSameQuadrant\r\n                    ? scoreSystemCells.sameQuadrantMultiplier\r\n                    : 1;\r\n\r\n                if (otherCell.player == null) {\r\n                    // Empty cell\r\n                    score.points += scoreSystemCells.empty * multiplier;\r\n                } else if (otherCell.player === player.id) {\r\n                    // Mine\r\n                    score.points += scoreSystemCells.mine * multiplier;\r\n                } else if (otherCell.player !== player.id) {\r\n                    // Opponent\r\n                    score.points += scoreSystemCells.opponent;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return score;\r\n}\r\n\r\n// Yields all cells that surround the given cell\r\nfunction getSurroundingCells(cell, rows) {\r\n    // dx / dy of surrounding cells\r\n    const coords = [\r\n        { row: cell.row, col: cell.col - 1 }, // left\r\n        { row: cell.row, col: cell.col + 1 }, // right\r\n        { row: cell.row - 1, col: cell.col }, // top\r\n        { row: cell.row + 1, col: cell.col }, // bottom\r\n        { row: cell.row - 1, col: cell.col - 1 }, // topleft\r\n        { row: cell.row - 1, col: cell.col + 1 }, // topright\r\n        { row: cell.row + 1, col: cell.col - 1 }, // bottomleft\r\n        { row: cell.row + 1, col: cell.col + 1 } // bottomright\r\n    ];\r\n\r\n    // Return those that exist\r\n    return coords.reduce((cells, possibleCell) => {\r\n        const { row, col } = possibleCell;\r\n        // Does it exist?\r\n        if (\r\n            row >= 0 &&\r\n            row < Constants.BOARD_SIZE &&\r\n            col >= 0 &&\r\n            col < Constants.BOARD_SIZE\r\n        ) {\r\n            cells.push(rows[row][col]);\r\n        }\r\n\r\n        return cells;\r\n    }, []);\r\n}\r\n\r\nexport const getBoardScoreByPlayer = createSelector(\r\n    getRows,\r\n    getMetadata,\r\n    getPlayers,\r\n    (rows, metadata, players) => {\r\n        const playerScores = {};\r\n\r\n        for (let player of players) {\r\n            playerScores[player.id] = scoreForPlayer(rows, metadata, player);\r\n        }\r\n\r\n        // This is a 2 player game\r\n        const playerOne = players[0];\r\n        const playerTwo = players[1];\r\n\r\n        const playerOnePoints = playerScores[playerOne.id].points;\r\n        const playerOneWins = playerScores[playerOne.id].wins;\r\n\r\n        const playerTwoPoints = playerScores[playerTwo.id].points;\r\n        const playerTwoWins = playerScores[playerTwo.id].wins;\r\n\r\n        return {\r\n            [playerOne.id]: {\r\n                points: playerOnePoints - playerTwoPoints,\r\n                pointsOne: playerOnePoints,\r\n                wins: playerOneWins\r\n            },\r\n            [playerTwo.id]: {\r\n                points: playerTwoPoints - playerOnePoints,\r\n                pointsTwo: playerTwoPoints,\r\n                wins: playerTwoWins\r\n            }\r\n        };\r\n    }\r\n);\r\n\r\n// Yields the ID of the cell's quadrant (0-based index, row to column)\r\nexport function getQuadrantId(cell) {\r\n    const qRow = Math.floor(cell.row / Constants.QUADRANT_SIZE);\r\n    const qCol = Math.floor(cell.col / Constants.QUADRANT_SIZE);\r\n\r\n    return qRow * Constants.NUM_QUADRANTS + qCol;\r\n}\r\n\r\n// Yields the Quadrant of the given cellId as { row: ..., column: ... }\r\nexport function getQuadrantRowAndColumn(state, cellId) {\r\n    const cell = getCell(state, cellId);\r\n\r\n    const row = Math.floor(cell.row / Constants.QUADRANT_SIZE);\r\n    const column = Math.floor(cell.col / Constants.QUADRANT_SIZE);\r\n\r\n    return { row, column };\r\n}\r\n","import { tryPickCell, rotateQuadrant, animateQuadrant } from \"./index\";\r\nimport {\r\n    getQuadrants,\r\n    getAvailableCells,\r\n    makeGetRotatedQuadrant,\r\n    getMetadata,\r\n    getBoardScoreByPlayer,\r\n    getQuadrantId\r\n} from \"../selectors/cellSelectors\";\r\nimport {\r\n    getActivePlayer,\r\n    getNextPlayer,\r\n    getPlayer,\r\n    getOtherPlayer\r\n} from \"../selectors/playerSelectors\";\r\nimport { chunk, maxElement, shuffle } from \"../helpers\";\r\nimport * as Constants from \"../constants\";\r\n\r\nlet boards = [\r\n    // {\r\n    //   cells: [],\r\n    //   rotation: { row: ..., column: ..., clockwise: ... },\r\n    //   metadata: {}\r\n    // }\r\n];\r\n\r\nlet currentPlayer;\r\nlet nextPlayer;\r\n\r\nexport function computeMove(showMove = true) {\r\n    return (dispatch, getState) => {\r\n        const state = getState();\r\n\r\n        // Game has already ended\r\n        if (state.gameOver) return { cellId: null, rotation: null };\r\n\r\n        currentPlayer = getActivePlayer(state);\r\n        nextPlayer = getNextPlayer(state);\r\n\r\n        boards = getBoards(getState);\r\n\r\n        // It is possible we have already picked a cell,\r\n        // if we were controlled by a human who picked one\r\n        // and then switched to being controlled by AI\r\n        // In that case, just pick the optimal rotation\r\n        let moveData = null;\r\n        if (!state.canPickCell) {\r\n            moveData = { rotation: optimalRotation(getState) };\r\n        } else {\r\n            // Cell + rotation\r\n            for (let moveFunction of optimalMovesInOrder) {\r\n                // console.log(`${currentPlayer.name}: Trying ${moveFunction.name}`);\r\n                moveData = moveFunction(getState);\r\n                if (moveData != null) {\r\n                    // console.log(`${currentPlayer.name}: Picked ${moveFunction.name}`);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Shows the move on the board (without actually doing the move)\r\n        if (showMove) {\r\n            dispatch(computedMove(moveData));\r\n        }\r\n\r\n        return moveData;\r\n    };\r\n}\r\n\r\nexport const COMPUTED_MOVE = \"COMPUTED_MOVE\";\r\nexport function computedMove(move) {\r\n    return {\r\n        type: COMPUTED_MOVE,\r\n        move: move\r\n    };\r\n}\r\n\r\nexport const HIDE_COMPUTED_MOVE = \"HIDE_COMPUTED_MOVE\";\r\nexport function hideComputedMove() {\r\n    return {\r\n        type: HIDE_COMPUTED_MOVE\r\n    };\r\n}\r\n\r\nexport function computeAndDoMove() {\r\n    return (dispatch, getState) => {\r\n        const state = getState();\r\n\r\n        // If we had already computed a move this turn,\r\n        // use that instead of computing a new one again\r\n        const { cellId, rotation } =\r\n            state.ui.computedMove || computeMove(false)(dispatch, getState);\r\n\r\n        let gameOver = false;\r\n\r\n        if (cellId != null) {\r\n            gameOver = dispatch(tryPickCell(cellId, currentPlayer.id));\r\n        }\r\n\r\n        // It is possible to have an AI do only a rotation\r\n        // when we switch a player to AI after picking a cell,\r\n        // therefore the rotation is not nested after picking the cell\r\n        if (!gameOver && rotation != null) {\r\n            const { row, column, clockwise } = rotation;\r\n\r\n            // Rotation (only if we haven't won by placing the cell)\r\n            if (state.options.animationsEnabled) {\r\n                dispatch(animateQuadrant(row, column, clockwise));\r\n            } else {\r\n                dispatch(rotateQuadrant(row, column, clockwise));\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// Build the 9 different boards (non-rotation and 8 rotations)\r\n// and compute their metadata\r\nfunction getBoards(getState) {\r\n    const boards = [];\r\n\r\n    // The current, non-rotated board\r\n    boards.push(initBoard(getState));\r\n\r\n    // All rotations of a single quadrant\r\n    for (let row = 0; row < Constants.NUM_QUADRANTS; row++) {\r\n        for (let column = 0; column < Constants.NUM_QUADRANTS; column++) {\r\n            for (let clockwise of [true, false]) {\r\n                const rotation = { row, column, clockwise };\r\n                boards.push(initBoard(getState, rotation));\r\n            }\r\n        }\r\n    }\r\n\r\n    return boards;\r\n}\r\n\r\nfunction initBoard(getState, rotation) {\r\n    const state = getState();\r\n\r\n    let cells;\r\n\r\n    if (rotation) {\r\n        const rotatedCells = makeGetRotatedQuadrant(\r\n            rotation.row,\r\n            rotation.column,\r\n            rotation.clockwise\r\n        )(state);\r\n        cells = Object.assign({}, state.cells, rotatedCells);\r\n    } else {\r\n        cells = Object.assign({}, state.cells);\r\n    }\r\n\r\n    const newState = Object.assign({}, state, {\r\n        cells: Object.assign({}, state.cells, cells)\r\n    });\r\n\r\n    const metadata = computeMetadata(() => newState);\r\n\r\n    return {\r\n        cells,\r\n        metadata,\r\n        rotation\r\n    };\r\n}\r\n\r\nconst optimalMovesInOrder = [\r\n    winningMove,\r\n    preventWinningMove,\r\n\r\n    lineInQuadrant,\r\n    preventLineInQuadrant,\r\n\r\n    makeLine4,\r\n    preventMakeLine4,\r\n\r\n    // setupMultipleLinesInQuadrant,\r\n\r\n    inCenter,\r\n    adjacentToSelf,\r\n    randomCell\r\n];\r\n\r\nfunction getBoard(rotation) {\r\n    const { row, column, clockwise } = rotation;\r\n\r\n    return boards.find(\r\n        board =>\r\n            board.rotation === rotation ||\r\n            (board.rotation != null &&\r\n                board.rotation.row === row &&\r\n                board.rotation.column === column &&\r\n                board.rotation.clockwise === clockwise)\r\n    );\r\n}\r\n\r\nfunction makeLine(\r\n    getState,\r\n    {\r\n        player = currentPlayer, // Search for a line with the given arguments for this player\r\n        doAsPlayer = currentPlayer, // This player will actually do the move, and we will do it optimally for this player\r\n        min = 3,\r\n        requiresFullQuadrant = false,\r\n        requiresRotation = true,\r\n        boardsToConsider = boards,\r\n        lookahead = true // Look ahead 1 move of rotations\r\n    } = {}\r\n) {\r\n    let optimal = {\r\n        score: null,\r\n        cellId: null,\r\n        rotation: null\r\n    };\r\n\r\n    for (let board of boardsToConsider) {\r\n        const rotation = board.rotation;\r\n\r\n        // Only look at rotations, if required\r\n        if (!rotation && requiresRotation) continue;\r\n\r\n        let meta = board.metadata[player.id];\r\n\r\n        if (requiresFullQuadrant) {\r\n            // Filter out any potential cells that\r\n            // do not at least fill a quadrant\r\n            const keys = Object.keys(meta);\r\n            const newMeta = {};\r\n\r\n            for (let key of keys) {\r\n                const potentials = meta[key];\r\n\r\n                for (let group of potentials) {\r\n                    const emptyCell = group.find(cell => cell.player == null);\r\n\r\n                    const qSize = Constants.QUADRANT_SIZE;\r\n                    const cellsByQuadrant = chunk(\r\n                        group,\r\n                        cell =>\r\n                            `${Math.floor(cell.row / qSize)}${Math.floor(\r\n                                cell.col / qSize\r\n                            )}`\r\n                    ).map(chunk => chunk[1]);\r\n                    // Empty cell completed a quadrant if the group it is part of is the length of a quadrant\r\n                    const groupOfEmptyCell = cellsByQuadrant.find(\r\n                        cells => cells.indexOf(emptyCell) > -1\r\n                    );\r\n                    const completesQuadrant =\r\n                        groupOfEmptyCell &&\r\n                        groupOfEmptyCell.length === Constants.QUADRANT_SIZE;\r\n\r\n                    // Fills a quadrant? Then we include it\r\n                    if (completesQuadrant) {\r\n                        (newMeta[key] || (newMeta[key] = [])).push(group);\r\n                    }\r\n                }\r\n            }\r\n\r\n            meta = newMeta;\r\n        }\r\n\r\n        const key = maxElement(Object.keys(meta).filter(key => key >= min));\r\n        let cell = null;\r\n        let cells = null;\r\n        if (key) {\r\n            // Introduce a bit of randomness\r\n            const metaCopy = shuffle(meta[key]);\r\n\r\n            cells = maxElement(metaCopy, group => {\r\n                const emptyCell = group.find(cell => cell.player == null);\r\n                if (!emptyCell) return null;\r\n\r\n                // State with current rotated cells\r\n                // and possibly the given cell\r\n                const state = Object.assign({}, getState(), {\r\n                    cells: Object.assign({}, board.cells, {\r\n                        [emptyCell.id]: Object.assign(\r\n                            {},\r\n                            board.cells[emptyCell.id],\r\n                            { player: doAsPlayer.id }\r\n                        )\r\n                    })\r\n                });\r\n\r\n                const score = getBoardScoreByPlayer(state);\r\n\r\n                return score[doAsPlayer.id].points;\r\n            });\r\n\r\n            cell = cells && cells.find(cell => cell.player == null);\r\n        }\r\n\r\n        if (cell) {\r\n            // State with current rotated cells\r\n            // and possibly the given cell\r\n            const state = Object.assign({}, getState(), {\r\n                cells: Object.assign({}, board.cells, {\r\n                    [cell.id]: Object.assign({}, board.cells[cell.id], {\r\n                        player: doAsPlayer.id\r\n                    })\r\n                })\r\n            });\r\n\r\n            const score = getBoardScoreByPlayer(state)[doAsPlayer.id];\r\n            const points = score.points;\r\n            const playerWins = score.wins;\r\n\r\n            // if(lookahead && !playerWins && player.id === doAsPlayer.id) {\r\n            //   const boards = getBoards(() => state);\r\n            //   const opponentWins = winningMove(() => state, { player: getOtherPlayer(doAsPlayer.id)(state), doAsPlayer: getOtherPlayer(doAsPlayer.id)(state), boardsToConsider: boards, lookahead: false });\r\n\r\n            //   if(opponentWins) {\r\n            //     // Cancel plans\r\n            //     console.log(\"DONT DO IT!\");\r\n            //     continue;\r\n            //   }\r\n            // }\r\n\r\n            if (\r\n                optimal.score == null ||\r\n                points > optimal.score ||\r\n                (points === optimal.score && Math.random() > 0.5)\r\n            ) {\r\n                optimal = {\r\n                    cellId: cell.id,\r\n                    score: points,\r\n                    rotation\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    if (optimal.cellId != null) {\r\n        return {\r\n            cellId: optimal.cellId,\r\n            rotation: optimal.rotation\r\n        };\r\n    }\r\n}\r\n\r\nfunction winningMove(\r\n    getState,\r\n    { player = currentPlayer, boardsToConsider = boards, lookahead = true } = {}\r\n) {\r\n    return makeLine(getState, {\r\n        min: Constants.AMOUNT_IN_LINE_TO_WIN,\r\n        player,\r\n        requiresRotation: false,\r\n        boardsToConsider,\r\n        lookahead\r\n    });\r\n}\r\n\r\nfunction preventWinningMove(getState) {\r\n    // First check if the opponent can win without rotating.\r\n    // If that is the case, we have to block the winning cell\r\n    // as rotating away can simply be undone by our opponent\r\n    let { cellId } =\r\n        winningMove(getState, {\r\n            player: nextPlayer,\r\n            doAsPlayer: currentPlayer,\r\n            boardsToConsider: boards.filter(board => !board.rotation)\r\n        }) || {};\r\n\r\n    if (cellId == null) {\r\n        return preventWithOptimalRotation(winningMove, getState);\r\n    } else {\r\n        // We found a winning cell to block,\r\n        // now just find an optimal rotation\r\n        return {\r\n            cellId,\r\n            rotation: optimalRotation(getState, cellId)\r\n        };\r\n    }\r\n}\r\n\r\nfunction makeLine4(getState, { player = currentPlayer } = {}) {\r\n    return makeLine(getState, { min: 4, player });\r\n}\r\n\r\nfunction preventMakeLine4(getState) {\r\n    return preventWithOptimalRotation(makeLine4, getState);\r\n}\r\n\r\nfunction preventWithOptimalRotation(func, getState, options) {\r\n    const move = func(\r\n        getState,\r\n        Object.assign({}, options, { player: nextPlayer })\r\n    );\r\n    if (!move) return null;\r\n\r\n    const { cellId } = move;\r\n\r\n    return {\r\n        cellId,\r\n        rotation: optimalRotation(getState, cellId)\r\n    };\r\n}\r\n\r\n// Will try get a setup in 1 quadrant similar to this:\r\n// | X | X |  |\r\n// +---+---+--+\r\n// | X |   |  |\r\n// +---+---+--+\r\n// |   |   |  |\r\n// +---+---+--+\r\n// i.e. it can always get 3 in a line in a quadrant\r\n// on the next turn, since there are 2 options here\r\nfunction setupMultipleLinesInQuadrant(\r\n    getState,\r\n    { player = currentPlayer } = {}\r\n) {\r\n    // We do NOT have to go through all rotations\r\n    // at first, since we are looking for a setup inside\r\n    // a single quadrant, rotating a quadrant will not\r\n    // have a meaningful influence\r\n\r\n    // First attempt: brute-force it\r\n    // This might not be to bad since there are no\r\n    // rotations involved and we brute-force on\r\n    // a relatively small set of the board to begin with\r\n    // -- all potential <quadrant_size - 1> in a line\r\n    // that are part of the same quadrant\r\n    const board = boards[0];\r\n\r\n    let meta = board.metadata[player.id];\r\n    let setups = meta[Constants.QUADRANT_SIZE - 1];\r\n\r\n    // No setups of the right size at all\r\n    if (!setups) return null;\r\n\r\n    // Select only those with all cells in the same quadrant\r\n    setups = setups.filter(cells =>\r\n        cells.every(cell => {\r\n            const quadrant = getQuadrantId(cell);\r\n            return cells.every(c => quadrant === getQuadrantId(c));\r\n        })\r\n    );\r\n\r\n    // For each group of cells, place a marble in the empty spot\r\n    // and check if this leads to any potential lines that fill the whole quadrant\r\n\r\n    const optimal = { cellId: null, amount: null };\r\n\r\n    for (let cells of setups) {\r\n        const cell = cells.find(cell => cell.player == null);\r\n\r\n        // State with current rotated cells\r\n        // and possibly the given cell\r\n        const state = Object.assign({}, getState(), {\r\n            cells: Object.assign({}, board.cells, {\r\n                [cell.id]: Object.assign({}, board.cells[cell.id], {\r\n                    player: player.id\r\n                })\r\n            })\r\n        });\r\n\r\n        const newMeta = getMetadata(state)[player.id];\r\n\r\n        // Does this move lead to potential full quadrant lines?\r\n        if (newMeta[Constants.QUADRANT_SIZE]) {\r\n            const fullQuadrantLines = newMeta[\r\n                Constants.QUADRANT_SIZE\r\n            ].filter(cells =>\r\n                cells.every(cell => {\r\n                    const quadrant = getQuadrantId(cell);\r\n                    return cells.every(c => quadrant === getQuadrantId(c));\r\n                })\r\n            );\r\n\r\n            if (fullQuadrantLines.length > 1) {\r\n                if (\r\n                    optimal.amount == null ||\r\n                    fullQuadrantLines.length > optimal.amount\r\n                ) {\r\n                    optimal.cellId = cell.id;\r\n                    optimal.amount = fullQuadrantLines.length;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Found a good one\r\n    if (optimal.cellId != null) {\r\n        return {\r\n            cellId: optimal.cellId,\r\n            // The rotation is irrelevant for this specific move\r\n            // so let's make sure we do the best one :)\r\n            rotation: optimalRotation(getState, optimal.cellId)\r\n        };\r\n    }\r\n\r\n    // No luck\r\n    return null;\r\n}\r\n\r\nfunction lineInQuadrant(getState, { player = currentPlayer } = {}) {\r\n    return makeLine(getState, { player, requiresFullQuadrant: true });\r\n}\r\n\r\nfunction preventLineInQuadrant(getState) {\r\n    return makeLine(getState, {\r\n        player: nextPlayer,\r\n        doAsPlayer: currentPlayer,\r\n        requiresFullQuadrant: true\r\n    });\r\n\r\n    // return preventWithOptimalRotation(lineInQuadrant, getState);\r\n}\r\n\r\nfunction inCenter(getState, player = currentPlayer.id) {\r\n    const rotation = optimalRotation(getState);\r\n\r\n    const board = getBoard(rotation);\r\n    const quadrants = getQuadrants({ cells: board.cells });\r\n\r\n    // Pick any of the quadrant centers of that board,\r\n    // preferably horizontally or vertically from\r\n    // on of the other centers that we already have\r\n    // rather than diagonally.\r\n\r\n    // The center is simply the middle cell of each quadrant\r\n    // This assumes the quadrant size is an odd number (obviously)\r\n    // otherwise there is no center :-)\r\n    const centers = quadrants.map(\r\n        q => q[Math.floor(q.length / 2)][Math.floor(q.length / 2)]\r\n    );\r\n\r\n    const playerCenters = centers.filter(\r\n        center => player != null && center.player === player\r\n    );\r\n    const availableCenters = centers.filter(center => center.player == null);\r\n\r\n    if (availableCenters.length > 0) {\r\n        // Prefer a center that is horizontally or vertically\r\n        // from one of the centers you already have, I believe it provides\r\n        // more options than diagonal centers due to more rotations towards\r\n        // each other (4 vs 2)\r\n        const cells = availableCenters.filter(\r\n            c =>\r\n                playerCenters.length === 0 ||\r\n                playerCenters.some(cc => c.row === cc.row || c.col === cc.col)\r\n        );\r\n\r\n        // Pick a random one from the good cells\r\n        let cell = cells[Math.floor(Math.random() * cells.length)];\r\n\r\n        // If no horizontal / vertical center is available, just choose one\r\n        cell =\r\n            cell ||\r\n            availableCenters[\r\n                Math.floor(Math.random() * availableCenters.length)\r\n            ];\r\n\r\n        return {\r\n            cellId: cell.id,\r\n            rotation\r\n        };\r\n    }\r\n\r\n    // None available\r\n    return null;\r\n}\r\n\r\nfunction adjacentToSelf(getState) {\r\n    return makeLine(getState, { min: 2 });\r\n}\r\n\r\nfunction randomCell(getState) {\r\n    const rotation = optimalRotation(getState);\r\n    const board = getBoard(rotation);\r\n    const cells = getAvailableCells({ cells: board.cells });\r\n    if (cells.length === 0) return;\r\n    const cell = cells[Math.floor(Math.random() * cells.length)];\r\n\r\n    return {\r\n        cellId: cell.id,\r\n        rotation\r\n    };\r\n}\r\n\r\nfunction optimalRotation(getState, cellId = null) {\r\n    let optimal = {\r\n        points: null,\r\n        rotation: null\r\n    };\r\n\r\n    for (const board of boards) {\r\n        const rotation = board.rotation;\r\n\r\n        if (!rotation) continue;\r\n\r\n        // State with current rotated cells\r\n        // and possibly the given cell\r\n        const state = Object.assign({}, getState(), {\r\n            cells: Object.assign(\r\n                {},\r\n                board.cells,\r\n                cellId == null\r\n                    ? null\r\n                    : {\r\n                          [cellId]: Object.assign({}, board.cells[cellId], {\r\n                              player: currentPlayer.id\r\n                          })\r\n                      }\r\n            )\r\n        });\r\n\r\n        const score = getBoardScoreByPlayer(state)[currentPlayer.id];\r\n        const points = score.points;\r\n        const playerWins = score.wins;\r\n\r\n        if (\r\n            optimal.points == null ||\r\n            points > optimal.points ||\r\n            (points === optimal.points && Math.random() > 0.5)\r\n        ) {\r\n            // We are about to replace our optimal rotation\r\n            // Make sure the opponent cannot win on the next turn\r\n            // with some move. This only applies to situations where we have are not winning ourselves, obviously\r\n            // if(!playerWins) {\r\n            //   const boards = getBoards(() => state);\r\n            //   const opponentWins = winningMove(() => state, { player: nextPlayer, boardsToConsider: boards });\r\n\r\n            //   if(opponentWins) {\r\n            //     // Cancel plans\r\n            //     continue;\r\n            //   }\r\n            // }\r\n\r\n            // All good\r\n            optimal = { points, rotation };\r\n        }\r\n    }\r\n\r\n    if (optimal.rotation) {\r\n        return optimal.rotation;\r\n    } else {\r\n        // If all rotations have been dropped because the opponent would win,\r\n        // we are officially screwed. We would lose anyway, just return a random rotation\r\n        const boardsWithRotation = boards.filter(\r\n            board => board.rotation != null\r\n        );\r\n        return boardsWithRotation[\r\n            Math.floor(Math.random() * boardsWithRotation.length)\r\n        ].rotation;\r\n    }\r\n}\r\n\r\nfunction computeMetadata(getState) {\r\n    return getMetadata(getState());\r\n}\r\n","import { computeAndDoMove } from \"./ai\";\r\nimport { getActivePlayerId } from \"../selectors/playerSelectors\";\r\n\r\nexport const SET_PLAYER_NAME = \"SET_PLAYER_NAME\";\r\nexport function setPlayerName(playerId, name) {\r\n    return {\r\n        type: SET_PLAYER_NAME,\r\n        playerId,\r\n        name\r\n    };\r\n}\r\n\r\nexport const SET_PLAYER_AI = \"SET_PLAYER_AI\";\r\nexport function setPlayerAI(playerId, isAI) {\r\n    return (dispatch, getState) => {\r\n        dispatch({\r\n            type: SET_PLAYER_AI,\r\n            playerId,\r\n            isAI\r\n        });\r\n\r\n        // If we just made a player an AI and\r\n        // it is the active player, execute a move!\r\n        if (isAI && getActivePlayerId(getState()) === playerId) {\r\n            dispatch(computeAndDoMove());\r\n        }\r\n    };\r\n}\r\n\r\nexport const TOGGLE_OPTIONS = \"TOGGLE_OPTIONS\";\r\nexport function toggleOptions() {\r\n    return {\r\n        type: TOGGLE_OPTIONS\r\n    };\r\n}\r\n\r\nexport const SET_AI_MOVE_DELAY = \"SET_AI_MOVE_DELAY\";\r\nexport function setAIMoveDelay(timeout) {\r\n    return {\r\n        type: SET_AI_MOVE_DELAY,\r\n        timeout\r\n    };\r\n}\r\n\r\nexport const SET_AUTOMATIC_RESTART = \"SET_AUTOMATIC_RESTART\";\r\nexport function setAutomaticRestart(enabled) {\r\n    return {\r\n        type: SET_AUTOMATIC_RESTART,\r\n        enabled\r\n    };\r\n}\r\n\r\nexport const SET_ANIMATIONS_ENABLED = \"SET_ANIMATIONS_ENABLED\";\r\nexport function setAnimationsEnabled(enabled) {\r\n    return {\r\n        type: SET_ANIMATIONS_ENABLED,\r\n        enabled\r\n    };\r\n}\r\n\r\nexport const SET_ANIMATION_DURATION = \"SET_ANIMATION_DURATION\";\r\nexport function setAnimationDuration(duration) {\r\n    return {\r\n        type: SET_ANIMATION_DURATION,\r\n        duration\r\n    };\r\n}\r\n\r\nexport const SET_SHOW_LOAD_SAVE_BUTTONS = \"SET_SHOW_LOAD_SAVE_BUTTONS\";\r\nexport function setShowLoadSaveButtons(show) {\r\n    return {\r\n        type: SET_SHOW_LOAD_SAVE_BUTTONS,\r\n        show\r\n    };\r\n}\r\n\r\nexport const SET_FIENE_MODE = \"SET_FIENE_MODE\";\r\nexport function setFieneMode(on) {\r\n    return {\r\n        type: SET_FIENE_MODE,\r\n        on: !!on\r\n    };\r\n}\r\n","import {\r\n    getAvailableCells,\r\n    getWinningCellsByPlayer,\r\n    getBoardScoreByPlayer,\r\n    getCell,\r\n    getQuadrantRowAndColumn\r\n} from \"../selectors/cellSelectors\";\r\nimport { getPlayers, getActivePlayer } from \"../selectors/playerSelectors\";\r\nimport { computeAndDoMove } from \"./ai\";\r\n\r\nexport const TRY_PICK_CELL = \"TRY_PICK_CELL\";\r\n// Returns: true/false if it's game over after picking the cell (due to win or draw)\r\nexport function tryPickCell(cellId, playerId) {\r\n    return (dispatch, getState) => {\r\n        const errorMessage = validateMove(getState, cellId, playerId);\r\n\r\n        if (errorMessage) {\r\n            return dispatch(showError(errorMessage));\r\n        }\r\n\r\n        // Cell\r\n        // The color is only shown in Fiene Mode\r\n        dispatch(pickCell(cellId, playerId, getState().ui.cellColor));\r\n\r\n        // Fiene Mode => we are not picking the quadrant to rotate anymore,\r\n        // instead we simply rotate the quadrant of the cell in a random direction\r\n        if (getState().options.fieneMode) {\r\n            const { row, column } = getQuadrantRowAndColumn(getState(), cellId);\r\n            dispatch(animateQuadrant(row, column, cellId % 2 === 0));\r\n        }\r\n\r\n        // Score\r\n        const scores = getBoardScoreByPlayer(getState());\r\n        dispatch(updateScores(scores));\r\n\r\n        return checkWinner(dispatch, getState);\r\n    };\r\n}\r\n\r\nexport const PICK_CELL = \"PICK_CELL\";\r\nexport function pickCell(cellId, playerId, color) {\r\n    return {\r\n        type: PICK_CELL,\r\n        cellId,\r\n        playerId,\r\n        color\r\n    };\r\n}\r\n\r\nfunction checkWinner(dispatch, getState) {\r\n    const state = getState();\r\n    let isDraw = false;\r\n\r\n    // In Fiene Mode, no one can ever win\r\n    if (!state.options.fieneMode) {\r\n        const players = getPlayers(state);\r\n\r\n        const winningCellsByPlayer = getWinningCellsByPlayer(state);\r\n\r\n        const winners = []; // Will hold objects of { player: <player>, winningCells: <winningCells> }\r\n        for (let player of players) {\r\n            const winningCells = winningCellsByPlayer[player.id];\r\n\r\n            if (winningCells) {\r\n                winners.push({\r\n                    player,\r\n                    winningCells\r\n                });\r\n            }\r\n        }\r\n\r\n        // Do we have winning cells?\r\n        if (winners.length > 0) {\r\n            const winningCells = winners.reduce(\r\n                (cells, winner) => cells.concat(winner.winningCells),\r\n                []\r\n            );\r\n            dispatch(setWinningCells(winningCells));\r\n        }\r\n\r\n        // Do we have a single winner?\r\n        if (winners.length === 1) {\r\n            const { player } = winners[0];\r\n\r\n            dispatch(playerWon(player.id));\r\n\r\n            // Reset, if specified\r\n            if (state.options.automaticRestart) {\r\n                setTimeout(() => dispatch(restartGame()), 500);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        // If both players won it's a draw\r\n        isDraw = winners.length === players.length;\r\n    }\r\n\r\n    // Also a draw => full board\r\n    // We only check this when necessary\r\n    if (!isDraw) {\r\n        const availableCells = getAvailableCells(state);\r\n        isDraw = availableCells.length === 0;\r\n    }\r\n\r\n    if (isDraw) {\r\n        dispatch(draw());\r\n\r\n        // Reset, if specified\r\n        if (state.options.automaticRestart) {\r\n            setTimeout(() => dispatch(restartGame()), 500);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Otherwise, no winner or draw\r\n    return false;\r\n}\r\n\r\nexport const DRAW = \"DRAW\";\r\nexport function draw() {\r\n    return {\r\n        type: DRAW\r\n    };\r\n}\r\n\r\nexport const PLAYER_WON = \"PLAYER_WON\";\r\nexport function playerWon(player) {\r\n    return {\r\n        type: PLAYER_WON,\r\n        player\r\n    };\r\n}\r\n\r\nexport const WINNING_CELLS = \"WINNING_CELLS\";\r\nexport function setWinningCells(cells) {\r\n    return {\r\n        type: WINNING_CELLS,\r\n        cells\r\n    };\r\n}\r\n\r\nexport const RESTART_GAME = \"RESTART_GAME\";\r\nexport function restartGame() {\r\n    return (dispatch, state) => {\r\n        dispatch({ type: RESTART_GAME });\r\n        dispatch(beginTurn());\r\n    };\r\n}\r\n\r\nexport const SELECT_QUADRANT = \"SELECT_QUADRANT\";\r\nexport function selectQuadrant(row, column) {\r\n    return {\r\n        type: SELECT_QUADRANT,\r\n        row,\r\n        column\r\n    };\r\n}\r\n\r\nexport const ANIMATE_QUADRANT = \"ANIMATE_QUADRANT\";\r\nexport function animateQuadrant(row, column, clockwise) {\r\n    return (dispatch, getState) => {\r\n        const state = getState();\r\n\r\n        // If animations are not enabled, fall back to immediate rotation\r\n        if (!state.options.animationsEnabled) {\r\n            dispatch(rotateQuadrant(row, column, clockwise));\r\n            return;\r\n        }\r\n\r\n        // Animation\r\n        dispatch({\r\n            type: ANIMATE_QUADRANT,\r\n            row,\r\n            column,\r\n            clockwise\r\n        });\r\n\r\n        // Actually rotate\r\n        const animationDuration = getState().options.animationDuration;\r\n        setTimeout(\r\n            () => dispatch(rotateQuadrant(row, column, clockwise)),\r\n            animationDuration\r\n        );\r\n    };\r\n}\r\n\r\nexport const ROTATE_QUADRANT = \"ROTATE_QUADRANT\";\r\n// Returns: true/false if it's game over after rotation\r\nexport function rotateQuadrant(row, column, clockwise) {\r\n    return (dispatch, getState) => {\r\n        dispatch(rotateQuadrantAction(row, column, clockwise));\r\n\r\n        // Scores\r\n        const scores = getBoardScoreByPlayer(getState());\r\n        dispatch(updateScores(scores));\r\n\r\n        const winningRotation = checkWinner(dispatch, getState);\r\n\r\n        if (!winningRotation) {\r\n            dispatch(beginTurn());\r\n        }\r\n\r\n        return winningRotation;\r\n    };\r\n}\r\n\r\nfunction rotateQuadrantAction(row, column, clockwise) {\r\n    return {\r\n        type: ROTATE_QUADRANT,\r\n        row,\r\n        column,\r\n        clockwise\r\n    };\r\n}\r\n\r\nfunction validateMove(getState, cellId, playerId) {\r\n    let errorMessage = null;\r\n\r\n    const state = getState();\r\n    const cell = getCell(getState(), cellId);\r\n\r\n    if (state.gameOver) {\r\n        errorMessage = `The game has ended`;\r\n    } else if (!cell) {\r\n        errorMessage = `Cell #${cell.id} does not exist!`;\r\n    } else if (cell.player != null) {\r\n        errorMessage = `Cell (${cell.row}, ${cell.col}) is not empty!`;\r\n    }\r\n\r\n    return errorMessage;\r\n}\r\n\r\nexport const SHOW_ERROR = \"SHOW_ERROR\";\r\nexport function showError(error) {\r\n    return {\r\n        type: SHOW_ERROR,\r\n        error\r\n    };\r\n}\r\n\r\nexport const HIDE_ERROR = \"HIDE_ERROR\";\r\nexport function hideError() {\r\n    return {\r\n        type: HIDE_ERROR\r\n    };\r\n}\r\n\r\nexport const BEGIN_TURN = \"BEGIN_TURN\";\r\nexport function beginTurn() {\r\n    return (dispatch, getState) => {\r\n        dispatch({ type: BEGIN_TURN });\r\n\r\n        const state = getState();\r\n        const player = getActivePlayer(state);\r\n\r\n        if (!player || !player.isAI) return;\r\n\r\n        // AI => compute its move and do it with a delay\r\n        const timeout = state.options.aiMoveDelay;\r\n        setTimeout(\r\n            () => dispatch(computeAndDoMove(dispatch, getState)),\r\n            timeout\r\n        );\r\n    };\r\n}\r\n\r\nexport const UPDATE_SCORES = \"UPDATE_SCORES\";\r\nexport function updateScores(scores) {\r\n    return {\r\n        type: UPDATE_SCORES,\r\n        scores\r\n    };\r\n}\r\n\r\nexport const SHOW_LAST_MOVE = \"SHOW_LAST_MOVE\";\r\nexport function showLastMove() {\r\n    return {\r\n        type: SHOW_LAST_MOVE\r\n    };\r\n}\r\n\r\nexport const HIDE_LAST_MOVE = \"HIDE_LAST_MOVE\";\r\nexport function hideLastMove() {\r\n    return {\r\n        type: HIDE_LAST_MOVE\r\n    };\r\n}\r\n","export const SAVE_TO_STORAGE = \"SAVE_TO_STORAGE\";\r\nexport function saveToStorage() {\r\n    return (dispatch, getState) => {\r\n        dispatch({ type: SAVE_TO_STORAGE });\r\n        window.localStorage.state = JSON.stringify(getState());\r\n    };\r\n}\r\n\r\nexport const LOAD_FROM_STORAGE = \"LOAD_FROM_STORAGE\";\r\nexport function loadFromStorage() {\r\n    return {\r\n        type: LOAD_FROM_STORAGE\r\n    };\r\n}\r\n\r\nexport const CLEAR_STORAGE = \"CLEAR_STORAGE\";\r\nexport function clearStorage() {\r\n    return (dispatch, getState) => {\r\n        dispatch({ type: CLEAR_STORAGE });\r\n        window.localStorage.removeItem(\"state\");\r\n    };\r\n}\r\n","import { PICK_CELL, ROTATE_QUADRANT, RESTART_GAME } from \"../actions\";\r\nimport { byId } from \"../helpers\";\r\nimport { BOARD_SIZE } from \"../constants\";\r\nimport { makeGetRotatedQuadrant } from \"../selectors/cellSelectors\";\r\n\r\nlet cellId = 0;\r\n\r\nconst allCells = [];\r\nfor (let row = 0; row < BOARD_SIZE; row++) {\r\n    for (let col = 0; col < BOARD_SIZE; col++) {\r\n        allCells.push({\r\n            id: cellId++,\r\n            row: row,\r\n            col: col\r\n        });\r\n    }\r\n}\r\n\r\nexport const initialState = byId(allCells);\r\n\r\nfunction cells(state = initialState, action) {\r\n    switch (action.type) {\r\n        case PICK_CELL:\r\n            const { cellId, color } = action;\r\n            const cell = state[cellId];\r\n\r\n            if (cell.player != null) {\r\n                throw new Error(\r\n                    `Cell (${cell.row}, ${cell.col}) is not empty!`\r\n                );\r\n            }\r\n\r\n            return Object.assign({}, state, {\r\n                [cell.id]: Object.assign({}, cell, {\r\n                    player: action.playerId,\r\n                    color\r\n                })\r\n            });\r\n\r\n        case ROTATE_QUADRANT:\r\n            const { row, column, clockwise } = action;\r\n\r\n            // These are just the changed cells of the quadrant\r\n            const rotatedQuadrant = makeGetRotatedQuadrant(\r\n                row,\r\n                column,\r\n                clockwise\r\n            )({ cells: state });\r\n\r\n            return Object.assign({}, state, rotatedQuadrant);\r\n\r\n        case RESTART_GAME:\r\n            return byId(allCells);\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport default cells;\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { tryPickCell } from \"../actions\";\r\nimport { getActivePlayer } from \"../selectors/playerSelectors\";\r\n\r\nconst Cell = ({\r\n    cell,\r\n    tryPickCell,\r\n    activePlayerId,\r\n    lastMove,\r\n    isEnabled,\r\n    canRotateQuadrant,\r\n    isWinningCell,\r\n    isComputedByAi,\r\n    showLastMove,\r\n    animationsEnabled,\r\n    animationDuration,\r\n    fieneMode\r\n}) => {\r\n    return (\r\n        <span\r\n            style={getStyle()}\r\n            className={getClassNames()}\r\n            onClick={\r\n                isEnabled ? () => tryPickCell(cell.id, activePlayerId) : null\r\n            }\r\n        />\r\n    );\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"cell\"];\r\n\r\n        if (!fieneMode && cell.player) {\r\n            classNames.push(`player-${cell.player}`);\r\n        } else {\r\n            if (!cell.color) {\r\n                classNames.push(\"empty\");\r\n            }\r\n        }\r\n\r\n        if (showLastMove && lastMove.cellId === cell.id) {\r\n            classNames.push(\"last-move\");\r\n        }\r\n\r\n        if (isWinningCell) {\r\n            classNames.push(\"winning\");\r\n        }\r\n\r\n        if (isComputedByAi) {\r\n            classNames.push(\"ai-preview\");\r\n        }\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n\r\n    function getStyle() {\r\n        const style = {};\r\n\r\n        if (animationsEnabled) {\r\n            const animationDurationInSeconds = animationDuration / 1000;\r\n\r\n            Object.assign(style, {\r\n                transition: `background-color ${animationDurationInSeconds}s`\r\n            });\r\n        }\r\n\r\n        if (fieneMode && cell.color) {\r\n            Object.assign(style, {\r\n                backgroundColor: cell.color\r\n            });\r\n        }\r\n\r\n        return style;\r\n    }\r\n};\r\n\r\nexport default connect(\r\n    (state, props) => ({\r\n        activePlayerId: state.activePlayer,\r\n        lastMove: state.lastMove,\r\n        isEnabled:\r\n            !state.ui.showLastMove &&\r\n            !state.draw &&\r\n            state.canPickCell &&\r\n            props.cell.player == null &&\r\n            (getActivePlayer(state) && !getActivePlayer(state).isAI),\r\n        canRotateQuadrant: !state.draw && state.canRotateQuadrant,\r\n        isWinningCell: state.ui.winningCells.some(\r\n            cell => cell.id === props.cell.id\r\n        ),\r\n        isComputedByAi:\r\n            state.ui.computedMove &&\r\n            state.ui.computedMove.cellId === props.cell.id,\r\n        showLastMove: state.ui.showLastMove,\r\n        animationsEnabled: state.options.animationsEnabled,\r\n        animationDuration: state.options.animationDuration,\r\n        fieneMode: state.options.fieneMode\r\n    }),\r\n    { tryPickCell }\r\n)(Cell);\r\n","import React from \"react\";\r\n\r\nexport const makeArrow = (\r\n    row,\r\n    column,\r\n    clockwise,\r\n    rotateQuadrant,\r\n    animateQuadrant,\r\n    aiRotation,\r\n    activePlayerId,\r\n    lastRotation,\r\n    showLastMove,\r\n    isSelected,\r\n    animationsEnabled\r\n) => ({ dangerouslySetInnerHTML, className }) => {\r\n    if (!dangerouslySetInnerHTML) return null;\r\n\r\n    return (\r\n        <span\r\n            {...{\r\n                dangerouslySetInnerHTML,\r\n                className: getClassNames(),\r\n                onClick: rotate\r\n            }}\r\n        />\r\n    );\r\n\r\n    function rotate(e) {\r\n        e.stopPropagation();\r\n        // We are showing a previous move,\r\n        // you cannot click to rotate currently\r\n        if (showLastMove) return false;\r\n        // Our Quadrant must be selected, otherwise something fishy is going on\r\n        if (!isSelected) return false;\r\n\r\n        if (animationsEnabled) {\r\n            animateQuadrant(row, column, clockwise);\r\n        } else {\r\n            rotateQuadrant(row, column, clockwise);\r\n        }\r\n    }\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"arrow\", className];\r\n\r\n        classNames.push(clockwise ? \"clockwise\" : \"counter-clockwise\");\r\n\r\n        // Are we using this arrow to show a computed AI move?\r\n        if (isSameRotation(aiRotation)) {\r\n            classNames.push(\"ai-preview\");\r\n        }\r\n\r\n        if (showLastMove && isSameRotation(lastRotation)) {\r\n            classNames.push(\"last-rotation\");\r\n        }\r\n\r\n        classNames.push(`player-${activePlayerId}`);\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n\r\n    function isSameRotation(rotation) {\r\n        return (\r\n            rotation &&\r\n            rotation.row === row &&\r\n            rotation.column === column &&\r\n            rotation.clockwise === clockwise\r\n        );\r\n    }\r\n};\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport Cell from \"../components/Cell\";\r\nimport { rotateQuadrant, animateQuadrant, selectQuadrant } from \"../actions\";\r\nimport clockwise from \"../svg/clockwise.svg\";\r\nimport counterClockwise from \"../svg/counter-clockwise.svg\";\r\nimport Isvg from \"react-inlinesvg\";\r\nimport { makeArrow } from \"./Arrow\";\r\n\r\nconst Quadrant = ({\r\n    quadrant,\r\n    canRotateQuadrant,\r\n    hasSelectedQuadrant,\r\n    isSelected,\r\n    row,\r\n    column,\r\n    rotateQuadrant,\r\n    selectQuadrant,\r\n    animateQuadrant,\r\n    aiRotation,\r\n    activePlayerId,\r\n    lastRotation,\r\n    showLastMove,\r\n    quadrantAnimation,\r\n    animationsEnabled,\r\n    animationDuration\r\n}) => {\r\n    return (\r\n        <div className={getClassNames()} style={getStyle()} onClick={onClick}>\r\n            {quadrant.map((row, i) =>\r\n                row.map(cell => <Cell key={`cell-${cell.id}`} cell={cell} />)\r\n            )}\r\n\r\n            <div className=\"arrows\">\r\n                <Isvg\r\n                    wrapper={makeArrow.apply(null, getArrowParams(true))}\r\n                    src={clockwise}\r\n                />\r\n                <Isvg\r\n                    wrapper={makeArrow.apply(null, getArrowParams(false))}\r\n                    src={counterClockwise}\r\n                />\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n    function getStyle() {\r\n        if (!animationsEnabled || !isThisQuadrant(quadrantAnimation))\r\n            return null;\r\n\r\n        const animationDurationInSeconds = animationDuration / 1000;\r\n\r\n        return {\r\n            transform: `rotate(${quadrantAnimation.clockwise ? 90 : -90}deg)`,\r\n            transition: `all ${animationDurationInSeconds}s linear`\r\n        };\r\n    }\r\n\r\n    function onClick(e) {\r\n        if (!canRotateQuadrant) return null;\r\n\r\n        e.stopPropagation();\r\n\r\n        selectQuadrant(row, column);\r\n    }\r\n\r\n    function getArrowParams(clockwise) {\r\n        return [\r\n            row,\r\n            column,\r\n            clockwise,\r\n            rotateQuadrant,\r\n            animateQuadrant,\r\n            aiRotation,\r\n            activePlayerId,\r\n            lastRotation,\r\n            showLastMove,\r\n            isSelected,\r\n            animationsEnabled\r\n        ];\r\n    }\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"quadrant\"];\r\n\r\n        if (isSelected) {\r\n            classNames.push(\"selected\");\r\n        }\r\n\r\n        if (\r\n            showLastMove &&\r\n            lastRotation != null &&\r\n            lastRotation.row === row &&\r\n            lastRotation.column === column\r\n        ) {\r\n            classNames.push(\"show-last-move\");\r\n        }\r\n\r\n        if (\r\n            aiRotation &&\r\n            aiRotation.row === row &&\r\n            aiRotation.column === column\r\n        ) {\r\n            classNames.push(\"ai-preview\");\r\n        }\r\n\r\n        if (isThisQuadrant(quadrantAnimation) && animationsEnabled) {\r\n            classNames.push(\"animating\");\r\n        }\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n\r\n    function isThisQuadrant(quadrantObject) {\r\n        return (\r\n            quadrantObject &&\r\n            quadrantObject.row === row &&\r\n            quadrantObject.column === column\r\n        );\r\n    }\r\n};\r\n\r\nexport default connect(\r\n    (state, props) => ({\r\n        canRotateQuadrant: !state.gameOver && state.canRotateQuadrant,\r\n        hasSelectedQuadrant: state.ui.selectedQuadrant.row != null,\r\n        isSelected:\r\n            state.ui.selectedQuadrant.row === props.row &&\r\n            state.ui.selectedQuadrant.column === props.column,\r\n        aiRotation: state.ui.computedMove && state.ui.computedMove.rotation,\r\n        activePlayerId: state.activePlayer,\r\n        lastRotation: state.lastMove.rotation,\r\n        showLastMove: state.ui.showLastMove,\r\n        quadrantAnimation: state.ui.quadrantAnimation,\r\n        animationsEnabled: state.options.animationsEnabled,\r\n        animationDuration: state.options.animationDuration\r\n    }),\r\n    { rotateQuadrant, animateQuadrant, selectQuadrant }\r\n)(Quadrant);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport Quadrant from \"./Quadrant\";\r\nimport { getQuadrants2D } from \"../selectors/cellSelectors\";\r\nimport { getActivePlayer } from \"../selectors/playerSelectors\";\r\n\r\nconst Board = ({ quadrants, disableCells, enableQuadrants, showLastMove }) => {\r\n    return (\r\n        <div className={getClassNames()}>\r\n            {quadrants.map((quadrantRow, i) =>\r\n                quadrantRow.map((quadrant, j) =>\r\n                    <Quadrant\r\n                        key={`quadrant-${i}-${j}`}\r\n                        row={i}\r\n                        column={j}\r\n                        quadrant={quadrant}\r\n                    />\r\n                )\r\n            )}\r\n        </div>\r\n    );\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"board\"];\r\n\r\n        if (disableCells) {\r\n            classNames.push(\"disable-cells\");\r\n        }\r\n\r\n        if (enableQuadrants) {\r\n            classNames.push(\"enable-quadrants\");\r\n        }\r\n\r\n        if (showLastMove) {\r\n            classNames.push(\"show-last-move\");\r\n            classNames.push(\"disable-cells\");\r\n        }\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n};\r\n\r\nexport default connect(state => ({\r\n    quadrants: getQuadrants2D(state),\r\n    disableCells:\r\n        state.gameOver ||\r\n        state.ui.isAnimating ||\r\n        !state.canPickCell ||\r\n        getActivePlayer(state).isAI,\r\n    enableQuadrants: !state.gameOver && state.canRotateQuadrant,\r\n    showLastMove: state.ui.showLastMove\r\n}))(Board);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { computeMove, hideComputedMove, computeAndDoMove } from \"../actions/ai\";\r\nimport {\r\n    showLastMove,\r\n    hideLastMove,\r\n    restartGame,\r\n    toggleOptions,\r\n    saveToStorage,\r\n    loadFromStorage,\r\n    clearStorage\r\n} from \"../actions\";\r\nimport { activePlayerIsAI } from \"../selectors/playerSelectors\";\r\n\r\nconst Controls = ({\r\n    gameOver,\r\n    hasPreviousMove,\r\n    showingLastMove,\r\n    showingOptions,\r\n    hasComputedMove,\r\n    showAIButtons,\r\n    hasStoredState,\r\n    disableAIButtons,\r\n    computeMove,\r\n    hideComputedMove,\r\n    computeAndDoMove,\r\n    showLastMove,\r\n    hideLastMove,\r\n    restartGame,\r\n    toggleOptions,\r\n    saveToStorage,\r\n    clearStorage,\r\n    loadFromStorage,\r\n    showLoadSaveButtons,\r\n    fieneMode\r\n}) => {\r\n    if (fieneMode && !gameOver) return null;\r\n\r\n    return (\r\n        <div className=\"controls\">\r\n            <div className=\"buttons\">\r\n                {!fieneMode &&\r\n                    hasPreviousMove &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={toggleLastMove}\r\n                    >\r\n                        {showingLastMove ? `Hide last move` : `Show last move`}\r\n                    </button>}\r\n\r\n                {!fieneMode &&\r\n                    gameOver &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={() => restartGame()}\r\n                    >\r\n                        Restart game\r\n                    </button>}\r\n\r\n                {fieneMode &&\r\n                    gameOver &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={() => restartGame()}\r\n                    >\r\n                        Nog een keer!\r\n                    </button>}\r\n\r\n                {!fieneMode &&\r\n                    showAIButtons &&\r\n                    (hasComputedMove\r\n                        ? <button\r\n                              className=\"btn\"\r\n                              type=\"button\"\r\n                              onClick={hideComputedMove}\r\n                          >\r\n                              Hide AI move\r\n                          </button>\r\n                        : <button\r\n                              className=\"btn\"\r\n                              type=\"button\"\r\n                              disabled={disableAIButtons}\r\n                              onClick={computeMove}\r\n                          >\r\n                              Compute AI move\r\n                          </button>)}\r\n\r\n                {!fieneMode &&\r\n                    showAIButtons &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        disabled={disableAIButtons}\r\n                        onClick={computeAndDoMove}\r\n                    >\r\n                        Execute AI move\r\n                    </button>}\r\n\r\n                {!fieneMode &&\r\n                    !showingOptions &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={toggleOptions}\r\n                    >\r\n                        Options\r\n                    </button>}\r\n\r\n                {!fieneMode &&\r\n                    showLoadSaveButtons &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={saveToStorage}\r\n                    >\r\n                        Save state\r\n                    </button>}\r\n                {!fieneMode &&\r\n                    showLoadSaveButtons &&\r\n                    hasStoredState &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={loadFromStorage}\r\n                    >\r\n                        Load state\r\n                    </button>}\r\n                {!fieneMode &&\r\n                    showLoadSaveButtons &&\r\n                    hasStoredState &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={clearStorage}\r\n                    >\r\n                        Clear state\r\n                    </button>}\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n    function toggleLastMove() {\r\n        if (showingLastMove) {\r\n            hideLastMove();\r\n        } else {\r\n            showLastMove();\r\n        }\r\n    }\r\n};\r\nexport default connect(\r\n    state => ({\r\n        gameOver: state.gameOver,\r\n        hasPreviousMove: state.lastMove.cellId != null,\r\n        showingLastMove: state.ui.showLastMove,\r\n        showingOptions: state.ui.showOptions,\r\n        hasComputedMove: state.ui.computedMove != null,\r\n        showAIButtons: !state.gameOver,\r\n        disableAIButtons:\r\n            !state.gameStarted ||\r\n            state.gameOver ||\r\n            activePlayerIsAI(state) ||\r\n            state.ui.isAnimating,\r\n        hasStoredState: state.hasStoredState,\r\n        showLoadSaveButtons: state.options.showLoadSaveButtons,\r\n        fieneMode: state.options.fieneMode\r\n    }),\r\n    {\r\n        computeMove,\r\n        hideComputedMove,\r\n        computeAndDoMove,\r\n        showLastMove,\r\n        hideLastMove,\r\n        restartGame,\r\n        toggleOptions,\r\n        saveToStorage,\r\n        loadFromStorage,\r\n        clearStorage\r\n    }\r\n)(Controls);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\n\r\nconst ErrorMessage = ({ error }) => {\r\n    if (!error) return null;\r\n\r\n    return (\r\n        <div className=\"error\">\r\n            {error}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default connect(state => ({ error: state.error }))(ErrorMessage);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { getActivePlayer, getPlayer } from \"../selectors/playerSelectors\";\r\nimport fiene from \"../img/fiene.png\";\r\n\r\nconst StatusMessage = ({\r\n    gameStarted,\r\n    gameOver,\r\n    activePlayer,\r\n    winner,\r\n    fieneMode\r\n}) => {\r\n    // If the game has not started yet, display the game title\r\n    if (!gameStarted) {\r\n        return <h1>Pentago</h1>;\r\n    }\r\n\r\n    if (fieneMode) {\r\n        if (!gameOver) {\r\n            return <img className=\"fiene\" src={fiene} alt=\"Fiene\" />;\r\n        } else {\r\n            return <h2>Afgelopen!</h2>;\r\n        }\r\n    } else {\r\n        // Game has not ended, but no active player (yet)\r\n        if (!gameOver && activePlayer == null) return null;\r\n\r\n        if (!gameOver) {\r\n            return <h2>{`Player: ${activePlayer.name}`}</h2>;\r\n        } else {\r\n            if (winner) {\r\n                return <h2>{`${winner.name} wins!`}</h2>;\r\n            } else {\r\n                return <h2>It's a draw</h2>;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nexport default connect(state => ({\r\n    gameStarted: state.gameStarted,\r\n    gameOver: state.gameOver,\r\n    activePlayer: getActivePlayer(state),\r\n    winner: getPlayer(state.winner)(state),\r\n    fieneMode: state.options.fieneMode\r\n}))(StatusMessage);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { getPlayers } from \"../selectors/playerSelectors\";\r\nimport {\r\n    setPlayerName,\r\n    setPlayerAI,\r\n    toggleOptions,\r\n    setAIMoveDelay,\r\n    setAutomaticRestart,\r\n    beginTurn,\r\n    setAnimationsEnabled,\r\n    setAnimationDuration,\r\n    setShowLoadSaveButtons,\r\n    setFieneMode\r\n} from \"../actions\";\r\n\r\nconst Options = ({\r\n    gameStarted,\r\n    players,\r\n    isVisible,\r\n    aiMoveDelay,\r\n    automaticRestart,\r\n    animationsEnabled,\r\n    animationDuration,\r\n    fieneMode,\r\n    setPlayerName,\r\n    setPlayerAI,\r\n    toggleOptions,\r\n    setAIMoveDelay,\r\n    setAutomaticRestart,\r\n    setAnimationsEnabled,\r\n    setAnimationDuration,\r\n    beginTurn,\r\n    setShowLoadSaveButtons,\r\n    showLoadSaveButtons,\r\n    setFieneMode\r\n}) => {\r\n    const player1 = players.find(player => player.id === 1);\r\n    const player2 = players.find(player => player.id === 2);\r\n\r\n    return (\r\n        <div className={getClassNames()}>\r\n            <h2>Options</h2>\r\n\r\n            <div className=\"option-columns\">\r\n                <div className=\"option-column\">\r\n                    <label htmlFor=\"player-1-name\">Player 1 name</label>\r\n                    <label htmlFor=\"player-1-ai\">Controlled by AI</label>\r\n\r\n                    <label htmlFor=\"player-2-name\">Player 2 name</label>\r\n                    <label htmlFor=\"player-2-ai\">Controlled by AI</label>\r\n\r\n                    <label htmlFor=\"aiMoveDelay\">AI move delay (ms)</label>\r\n\r\n                    <label htmlFor=\"animationsEnabled\">\r\n                        Animations enabled\r\n                    </label>\r\n                    <label htmlFor=\"animationDuration\">\r\n                        Animation duration (ms)\r\n                    </label>\r\n\r\n                    <label htmlFor=\"automaticRestart\">Autorestart game</label>\r\n                    <label htmlFor=\"fieneMode\">Fiene Mode</label>\r\n\r\n                    <label htmlFor=\"showLoadSaveButtons\">\r\n                        Show load and save buttons\r\n                    </label>\r\n                </div>\r\n                <div className=\"option-column\">\r\n                    <input\r\n                        type=\"text\"\r\n                        value={player1.name}\r\n                        id=\"player-1-name\"\r\n                        onChange={e =>\r\n                            setPlayerName(player1.id, e.target.value)}\r\n                    />\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"player-1-ai\"\r\n                        checked={player1.isAI}\r\n                        onChange={e =>\r\n                            setPlayerAI(player1.id, e.target.checked)}\r\n                    />\r\n\r\n                    <input\r\n                        type=\"text\"\r\n                        value={player2.name}\r\n                        id=\"player-2-name\"\r\n                        onChange={e =>\r\n                            setPlayerName(player2.id, e.target.value)}\r\n                    />\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"player-2-ai\"\r\n                        checked={player2.isAI}\r\n                        onChange={e =>\r\n                            setPlayerAI(player2.id, e.target.checked)}\r\n                    />\r\n\r\n                    <input\r\n                        type=\"text\"\r\n                        id=\"aiMoveDelay\"\r\n                        defaultValue={aiMoveDelay}\r\n                        onBlur={e =>\r\n                            setAIMoveDelay(parseInt(e.target.value, 10))}\r\n                    />\r\n\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"animationsEnabled\"\r\n                        checked={animationsEnabled}\r\n                        onChange={e => setAnimationsEnabled(e.target.checked)}\r\n                    />\r\n                    <input\r\n                        type=\"text\"\r\n                        id=\"animationDuration\"\r\n                        defaultValue={animationDuration}\r\n                        onBlur={e =>\r\n                            setAnimationDuration(parseInt(e.target.value, 10))}\r\n                    />\r\n\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"automaticRestart\"\r\n                        checked={automaticRestart}\r\n                        onChange={e => setAutomaticRestart(e.target.checked)}\r\n                    />\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"fieneMode\"\r\n                        checked={fieneMode}\r\n                        onChange={e => setFieneMode(e.target.checked)}\r\n                    />\r\n\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"showLoadSaveButtons\"\r\n                        checked={showLoadSaveButtons}\r\n                        onChange={e => setShowLoadSaveButtons(e.target.checked)}\r\n                    />\r\n                </div>\r\n            </div>\r\n\r\n            {isVisible && gameStarted\r\n                ? <button type=\"button\" className=\"btn\" onClick={toggleOptions}>\r\n                      Close\r\n                  </button>\r\n                : <button type=\"button\" className=\"btn\" onClick={startGame}>\r\n                      Start game\r\n                  </button>}\r\n        </div>\r\n    );\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"options\"];\r\n\r\n        if (isVisible) {\r\n            classNames.push(\"visible\");\r\n        }\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n\r\n    function startGame() {\r\n        toggleOptions();\r\n        beginTurn();\r\n    }\r\n};\r\n\r\nexport default connect(\r\n    state => ({\r\n        gameStarted: state.gameStarted,\r\n        players: getPlayers(state),\r\n        isVisible: state.ui.showOptions,\r\n        aiMoveDelay: state.options.aiMoveDelay,\r\n        automaticRestart: state.options.automaticRestart,\r\n        animationsEnabled: state.options.animationsEnabled,\r\n        animationDuration: state.options.animationDuration,\r\n        showLoadSaveButtons: state.options.showLoadSaveButtons,\r\n        fieneMode: state.options.fieneMode\r\n    }),\r\n    {\r\n        setPlayerName,\r\n        setPlayerAI,\r\n        toggleOptions,\r\n        setAIMoveDelay,\r\n        setAutomaticRestart,\r\n        setAnimationsEnabled,\r\n        setAnimationDuration,\r\n        beginTurn,\r\n        setShowLoadSaveButtons,\r\n        setFieneMode\r\n    }\r\n)(Options);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { getPlayers } from \"../selectors/playerSelectors\";\r\n\r\nconst Score = ({ score, players, fieneMode }) => {\r\n    if (fieneMode) return null;\r\n\r\n    return (\r\n        <div className=\"score\">\r\n            <h2>Score</h2>\r\n            <h3>\r\n                {players[0].name} {score[players[0].id] || 0} -{\" \"}\r\n                {score[players[1].id] || 0} {players[1].name}\r\n            </h3>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default connect(state => ({\r\n    players: getPlayers(state),\r\n    score: state.ui.score,\r\n    fieneMode: state.options.fieneMode\r\n}))(Score);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport Board from \"./Board\";\r\nimport Controls from \"./Controls\";\r\nimport ErrorMessage from \"./ErrorMessage\";\r\nimport StatusMessage from \"./StatusMessage\";\r\nimport Options from \"./Options\";\r\nimport Score from \"./Score\";\r\n\r\nconst Game = ({ activePlayerId, gameOver, score, boardScores, fieneMode }) => {\r\n    return (\r\n        <div className={getClassNames()}>\r\n            <div className=\"column-center\">\r\n                <StatusMessage />\r\n                <Board />\r\n                <Score />\r\n\r\n                {\r\n                    // <pre style={ { textAlign: 'left', fontSize: '12pt', position: 'absolute', left: '15%' }  }>\r\n                    //   { JSON.stringify(boardScores, null, 4) }\r\n                    // </pre>\r\n                }\r\n\r\n                <Controls />\r\n                <ErrorMessage />\r\n                <Options />\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"game\"];\r\n\r\n        if (gameOver) {\r\n            classNames.push(\"game-over\");\r\n        }\r\n\r\n        if (!fieneMode && activePlayerId) {\r\n            classNames.push(`player-${activePlayerId}`);\r\n        }\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n};\r\n\r\nexport default connect(state => ({\r\n    activePlayerId: state.activePlayer,\r\n    gameOver: state.gameOver,\r\n    score: state.ui.score,\r\n    boardScores: state.scores,\r\n    fieneMode: state.options.fieneMode\r\n}))(Game);\r\n","import React from \"react\";\r\nimport { createDevTools } from \"redux-devtools\";\r\nimport LogMonitor from \"redux-devtools-log-monitor\";\r\nimport DockMonitor from \"redux-devtools-dock-monitor\";\r\n\r\nexport default createDevTools(\r\n    <DockMonitor toggleVisibilityKey=\"ctrl-h\" changePositionKey=\"ctrl-j\">\r\n        <LogMonitor />\r\n    </DockMonitor>\r\n);\r\n","import React from \"react\";\nimport Game from \"./Game\";\nimport DevTools from \"./DevTools\";\n\nconst Pentago = () =>\n    <div>\n        <Game />\n        {\n            // <DevTools />\n        }\n    </div>;\n\nexport default Pentago;\n","import { byId } from \"../helpers\";\r\nimport { SET_PLAYER_NAME, SET_PLAYER_AI, SET_FIENE_MODE } from \"../actions\";\r\n\r\nconst allPlayers = [\r\n    { id: 1, name: \"Red\", isAI: true },\r\n    { id: 2, name: \"Blue\", isAI: false }\r\n];\r\n\r\nexport const initialState = byId(allPlayers);\r\n\r\nexport default (state = initialState, action) => {\r\n    switch (action.type) {\r\n        case SET_PLAYER_NAME: {\r\n            const { playerId, name } = action;\r\n\r\n            return Object.assign({}, state, {\r\n                [playerId]: Object.assign({}, state[playerId], {\r\n                    name: name\r\n                })\r\n            });\r\n        }\r\n\r\n        case SET_PLAYER_AI: {\r\n            const { playerId, isAI } = action;\r\n\r\n            return Object.assign({}, state, {\r\n                [playerId]: Object.assign({}, state[playerId], {\r\n                    isAI: isAI\r\n                })\r\n            });\r\n        }\r\n\r\n        // In Fiene Mode, there is no AI\r\n        case SET_FIENE_MODE:\r\n            const { on } = action;\r\n            if (on) {\r\n                const newState = Object.assign({}, state);\r\n\r\n                for (let key of Object.keys(newState)) {\r\n                    newState[key] = Object.assign(newState[key], {\r\n                        isAI: false\r\n                    });\r\n                }\r\n\r\n                return newState;\r\n            }\r\n            break;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n","import { combineReducers } from \"redux\";\r\nimport {\r\n    SELECT_QUADRANT,\r\n    PICK_CELL,\r\n    ROTATE_QUADRANT,\r\n    ANIMATE_QUADRANT,\r\n    PLAYER_WON,\r\n    BEGIN_TURN,\r\n    SHOW_LAST_MOVE,\r\n    HIDE_LAST_MOVE,\r\n    RESTART_GAME,\r\n    TOGGLE_OPTIONS,\r\n    WINNING_CELLS\r\n} from \"../actions\";\r\nimport { COMPUTED_MOVE, HIDE_COMPUTED_MOVE } from \"../actions/ai\";\r\nimport { COLORS } from \"../constants\";\r\n\r\nfunction selectedQuadrant(state = {}, action) {\r\n    switch (action.type) {\r\n        case SELECT_QUADRANT:\r\n            const { row, column } = action;\r\n            return Object.assign({}, { row, column });\r\n\r\n        case ROTATE_QUADRANT:\r\n        case RESTART_GAME:\r\n            return {};\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction winningCells(state = [], action) {\r\n    switch (action.type) {\r\n        case WINNING_CELLS:\r\n            return action.cells;\r\n\r\n        case RESTART_GAME:\r\n            return [];\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction score(state = {}, action) {\r\n    switch (action.type) {\r\n        case PLAYER_WON:\r\n            return Object.assign({}, state, {\r\n                [action.player]: (state[action.player] || 0) + 1\r\n            });\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction computedMove(state = null, action) {\r\n    switch (action.type) {\r\n        case COMPUTED_MOVE:\r\n            return action.move;\r\n\r\n        case HIDE_COMPUTED_MOVE:\r\n            return null;\r\n\r\n        case PICK_CELL:\r\n        case ROTATE_QUADRANT:\r\n        case BEGIN_TURN:\r\n            return null;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction showLastMove(state = false, action) {\r\n    switch (action.type) {\r\n        case SHOW_LAST_MOVE:\r\n            return true;\r\n\r\n        case HIDE_LAST_MOVE:\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction showOptions(state = true, action) {\r\n    switch (action.type) {\r\n        case TOGGLE_OPTIONS:\r\n            return !state;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction quadrantAnimation(state = null, action) {\r\n    switch (action.type) {\r\n        case ANIMATE_QUADRANT:\r\n            const { row, column, clockwise } = action;\r\n            return { row, column, clockwise };\r\n\r\n        case ROTATE_QUADRANT:\r\n        case RESTART_GAME:\r\n            return null;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction isAnimating(state = false, action) {\r\n    switch (action.type) {\r\n        case ANIMATE_QUADRANT:\r\n            return true;\r\n\r\n        case ROTATE_QUADRANT:\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction cellColor(state = null, action) {\r\n    switch (action.type) {\r\n        case BEGIN_TURN:\r\n        case ROTATE_QUADRANT:\r\n            // Pick a new color\r\n            return COLORS[Math.floor(Math.random() * COLORS.length)];\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst uiReducer = combineReducers({\r\n    selectedQuadrant,\r\n    winningCells,\r\n    score,\r\n    computedMove,\r\n    showLastMove,\r\n    showOptions,\r\n    quadrantAnimation,\r\n    isAnimating,\r\n    cellColor\r\n});\r\n\r\nexport default uiReducer;\r\n","import { combineReducers } from \"redux\";\r\nimport {\r\n    SET_AI_MOVE_DELAY,\r\n    SET_AUTOMATIC_RESTART,\r\n    SET_ANIMATIONS_ENABLED,\r\n    SET_ANIMATION_DURATION,\r\n    SET_SHOW_LOAD_SAVE_BUTTONS,\r\n    SET_FIENE_MODE\r\n} from \"../actions\";\r\n\r\nfunction aiMoveDelay(state = 500, action) {\r\n    switch (action.type) {\r\n        case SET_AI_MOVE_DELAY:\r\n            const { timeout } = action;\r\n\r\n            if (isNaN(timeout) || typeof timeout !== \"number\") {\r\n                return state;\r\n            }\r\n\r\n            return timeout;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction automaticRestart(state = false, action) {\r\n    switch (action.type) {\r\n        case SET_AUTOMATIC_RESTART:\r\n            const { enabled } = action;\r\n            return enabled;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction animationsEnabled(state = true, action) {\r\n    switch (action.type) {\r\n        case SET_ANIMATIONS_ENABLED:\r\n            const { enabled } = action;\r\n            return enabled;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction animationDuration(state = 500, action) {\r\n    switch (action.type) {\r\n        case SET_ANIMATION_DURATION:\r\n            const { duration } = action;\r\n\r\n            if (isNaN(duration) || typeof duration !== \"number\") {\r\n                return state;\r\n            }\r\n\r\n            return duration;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction showLoadSaveButtons(state = false, action) {\r\n    switch (action.type) {\r\n        case SET_SHOW_LOAD_SAVE_BUTTONS:\r\n            const { show } = action;\r\n            return show;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction fieneMode(state = false, action) {\r\n    switch (action.type) {\r\n        case SET_FIENE_MODE:\r\n            const { on } = action;\r\n            return on;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst optionsReducer = combineReducers({\r\n    aiMoveDelay,\r\n    automaticRestart,\r\n    animationsEnabled,\r\n    animationDuration,\r\n    showLoadSaveButtons,\r\n    fieneMode\r\n});\r\n\r\nexport default optionsReducer;\r\n","import { combineReducers } from \"redux\";\r\nimport cellsReducer from \"./cellsReducer\";\r\nimport playersReducer from \"./playersReducer\";\r\nimport uiReducer from \"./uiReducer\";\r\nimport optionsReducer from \"./optionsReducer\";\r\nimport {\r\n    PICK_CELL,\r\n    ROTATE_QUADRANT,\r\n    ANIMATE_QUADRANT,\r\n    SHOW_ERROR,\r\n    HIDE_ERROR,\r\n    BEGIN_TURN,\r\n    PLAYER_WON,\r\n    DRAW,\r\n    RESTART_GAME,\r\n    UPDATE_SCORES,\r\n    LOAD_FROM_STORAGE,\r\n    SAVE_TO_STORAGE,\r\n    CLEAR_STORAGE\r\n} from \"../actions\";\r\n\r\nconst rootReducer = combineReducers({\r\n    cells: cellsReducer,\r\n    players: playersReducer,\r\n    ui: uiReducer,\r\n    options: optionsReducer,\r\n    gameStarted,\r\n    activePlayer,\r\n    lastMove,\r\n    winner,\r\n    gameOver,\r\n    error,\r\n    canPickCell,\r\n    canRotateQuadrant,\r\n    scores,\r\n    hasStoredState\r\n});\r\n\r\nexport default function(state = {}, action) {\r\n    state = localStorage(state, action);\r\n    return rootReducer(state, action);\r\n}\r\n\r\nfunction localStorage(state = {}, action) {\r\n    switch (action.type) {\r\n        case LOAD_FROM_STORAGE:\r\n            const stored = window.localStorage.state;\r\n            if (!stored) return state;\r\n\r\n            try {\r\n                return JSON.parse(stored);\r\n            } catch (e) {\r\n                return state;\r\n            }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction activePlayer(state = 1, action) {\r\n    switch (action.type) {\r\n        case ROTATE_QUADRANT:\r\n            return state % 2 + 1;\r\n\r\n        case RESTART_GAME:\r\n            return 1;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction lastMove(state = {}, action) {\r\n    switch (action.type) {\r\n        case PICK_CELL:\r\n            // Erase rotation of previous player\r\n            return { cellId: action.cellId };\r\n\r\n        case ANIMATE_QUADRANT:\r\n        case ROTATE_QUADRANT:\r\n            const { row, column, clockwise } = action;\r\n\r\n            // Add rotation to current player\r\n            return Object.assign({}, state, {\r\n                rotation: { row, column, clockwise }\r\n            });\r\n\r\n        case RESTART_GAME:\r\n            return {};\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction winner(state = null, action) {\r\n    switch (action.type) {\r\n        case PLAYER_WON:\r\n            return action.player;\r\n\r\n        case RESTART_GAME:\r\n            return null;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction gameOver(state = false, action) {\r\n    switch (action.type) {\r\n        case PLAYER_WON:\r\n        case DRAW:\r\n            return true;\r\n\r\n        case RESTART_GAME:\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction error(state = null, action) {\r\n    switch (action.type) {\r\n        case SHOW_ERROR:\r\n            return action.error;\r\n\r\n        case HIDE_ERROR:\r\n        case PICK_CELL:\r\n            return null;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction canPickCell(state = false, action) {\r\n    switch (action.type) {\r\n        case BEGIN_TURN:\r\n            return true;\r\n\r\n        case PICK_CELL:\r\n        case RESTART_GAME:\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction canRotateQuadrant(state = false, action) {\r\n    switch (action.type) {\r\n        case ANIMATE_QUADRANT:\r\n        case ROTATE_QUADRANT:\r\n        case RESTART_GAME:\r\n            return false;\r\n\r\n        case PICK_CELL:\r\n            return true;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction scores(state = {}, action) {\r\n    switch (action.type) {\r\n        case UPDATE_SCORES:\r\n            return action.scores;\r\n\r\n        case RESTART_GAME:\r\n            return {};\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction gameStarted(state = false, action) {\r\n    switch (action.type) {\r\n        case BEGIN_TURN:\r\n            return true;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction hasStoredState(state, action) {\r\n    if (typeof state === \"undefined\") {\r\n        return window.localStorage.state != null;\r\n    }\r\n\r\n    switch (action.type) {\r\n        case SAVE_TO_STORAGE:\r\n            return true;\r\n\r\n        case CLEAR_STORAGE:\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (!isLocalhost) {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      } else {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import \"./polyfills\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Pentago from \"./components/Pentago\";\nimport { Provider } from \"react-redux\";\nimport buildStore from \"./store/buildStore\";\nimport \"./css/index.css\";\nimport registerServiceWorker from \"./registerServiceWorker\";\n\nconst store = buildStore();\n\nReactDOM.render(\n    <Provider store={store}>\n        <Pentago />\n    </Provider>,\n    document.getElementById(\"root\")\n);\n\n// This only works on secure origins (i.e., not http://)\n// registerServiceWorker();\n","import { createStore, applyMiddleware, compose } from \"redux\";\r\nimport thunk from \"redux-thunk\";\r\nimport DevTools from \"../components/DevTools\";\r\nimport rootReducer from \"../reducers/rootReducer\";\r\n\r\nexport default initialState =>\r\n    createStore(\r\n        rootReducer,\r\n        initialState,\r\n        compose(applyMiddleware(thunk), DevTools.instrument())\r\n    );\r\n"],"sourceRoot":""}