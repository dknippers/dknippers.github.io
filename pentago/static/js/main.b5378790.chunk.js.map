{"version":3,"sources":["svg/clockwise.svg","svg/counter-clockwise.svg","img/fiene.png","helpers/index.js","selectors/playerSelectors.js","constants/index.js","selectors/cellSelectors.js","actions/ai.js","actions/options.js","actions/game.js","reducers/cellsReducer.js","components/Cell.js","components/Arrow.js","components/Quadrant.js","components/Board.js","components/Controls.js","actions/localStorage.js","components/ErrorMessage.js","components/StatusMessage.js","components/Options.js","components/Score.js","components/Game.js","components/DevTools.js","components/Pentago.js","reducers/playersReducer.js","reducers/uiReducer.js","reducers/optionsReducer.js","reducers/rootReducer.js","registerServiceWorker.js","index.js","store/buildStore.js"],"names":["module","exports","byId","array","reduce","element","id","chunk","func","keepNullOrUndefined","Array","isArray","Error","chunks","length","prevValue","prevElements","newValue","push","filter","groupBy","grouped","key","shuffle","a","j","x","i","newA","from","Math","floor","random","greaterThan","y","minOrMax","operator","compareBy","transform","mmData","mmValue","value","mmElement","max","maxElement","maxBy","transpose","some","subArray","maxColSize","maxValue","transposed","col","row","getPlayersById","state","players","getActivePlayerId","activePlayer","getPlayers","createSelector","playersById","Object","keys","map","getActivePlayer","activePlayerId","getNextPlayer","nextPlayerId","activePlayerIsAI","player","isAI","NUM_QUADRANTS","BOARD_SIZE","colors","forEach","hue","randomColor","luminosity","COLORS","getCells","cells","cellsById","getCell","getAvailableCells","cell","getSortedCells","sort","getRows","rows","getColumns","columns","getDiagonals","diagonals","collectionOfDiagonals","diagonal","findWinningCellsInLines","lines","winningCells","winsInLine","getWinningCellsByPlayer","winningCellsByPlayer","line","find","quadrantMinAndMaxRowOrCol","rowOrCol","quadrantMinAndMaxRow","quadrantMinAndMaxCol","getQuadrant","minRow","maxRow","minCol","maxCol","getQuadrants","quadrants","r","Constants","c","getQuadrants2D","rotateClockwise","quadrant","reverse","rotateCounterclockwise","rotate","turnClockwise","makeGetRotatedQuadrant","column","clockwise","makeGetQuadrant","rotated","irow","icol","assign","getMetadata","cellsInLine","metadata","potentials","potentialAmountInLine","computePotentialsInLine","group","maxAdjacentsInLine","groups","isEmpty","firstCell","firstIdx","indexOf","lastCell","isLastAndEmpty","prevGroup","prevGroupIsEmpty","every","prevLastCell","prevLastIdx","abs","pop","emptyIdx","findIndex","slice","scoreForPlayer","scoreSystemPotentials","2","3","4","5","6","fillQuadrantMultiplier","noFriendliesAround","score","points","wins","k","parseInt","n","base","chunkedCells","multiplier","emptyCell","surroundingCells","getSurroundingCells","quadrantOfEmptyCell","getQuadrantId","scoreSystemCells","cellQuadrantId","missingCells","otherCell","possibleCell","getBoardScoreByPlayer","playerScores","playerOne","playerTwo","playerOnePoints","playerOneWins","playerTwoPoints","playerTwoWins","pointsOne","pointsTwo","qRow","qCol","currentPlayer","nextPlayer","boards","computeMove","showMove","dispatch","getState","gameOver","cellId","rotation","getBoards","moveData","canPickCell","optimalMovesInOrder","moveFunction","optimalRotation","computedMove","move","type","computeAndDoMove","ui","tryPickCell","options","animationsEnabled","animateQuadrant","rotateQuadrant","initBoard","rotatedCells","newState","computeMetadata","winningMove","doAsPlayer","boardsToConsider","board","preventWithOptimalRotation","makeLine","requiresFullQuadrant","makeLine4","getBoard","centers","q","playerCenters","center","availableCenters","cc","min","requiresRotation","optimal","lookahead","meta","newMeta","groupOfEmptyCell","boardsWithRotation","toggleOptions","playerId","errorMessage","validateMove","error","color","PICK_CELL","pickCell","cellColor","fieneMode","getQuadrantRowAndColumn","updateScores","checkWinner","isDraw","winners","winner","concat","playerWon","automaticRestart","setTimeout","restartGame","RESTART_GAME","beginTurn","animationDuration","ROTATE_QUADRANT","rotateQuadrantAction","winningRotation","timeout","aiMoveDelay","scores","connect","props","lastMove","isEnabled","showLastMove","draw","canRotateQuadrant","isWinningCell","isComputedByAi","style","animationDurationInSeconds","transition","backgroundColor","getStyle","className","classNames","join","getClassNames","onClick","Arrow","aiRotation","lastRotation","isSelected","src","isSameRotation","e","stopPropagation","clockwiseArrow","counterClockwiseArrow","hasSelectedQuadrant","selectedQuadrant","quadrantAnimation","selectQuadrant","isThisQuadrant","getArrowParams","quadrantObject","disableCells","isAnimating","enableQuadrants","quadrantRow","hasPreviousMove","showingLastMove","showingOptions","showOptions","hasComputedMove","showAIButtons","disableAIButtons","gameStarted","hasStoredState","showLoadSaveButtons","hideComputedMove","hideLastMove","saveToStorage","window","localStorage","JSON","stringify","loadFromStorage","clearStorage","removeItem","disabled","fiene","alt","name","isVisible","setPlayerName","setPlayerAI","setAIMoveDelay","setAutomaticRestart","enabled","setAnimationsEnabled","setAnimationDuration","duration","setShowLoadSaveButtons","show","setFieneMode","on","player1","player2","htmlFor","onChange","target","checked","defaultValue","onBlur","boardScores","createDevTools","toggleVisibilityKey","changePositionKey","Pentago","allCells","initialState","action","rotatedQuadrant","uiReducer","combineReducers","optionsReducer","isNaN","rootReducer","cellsReducer","stored","parse","Boolean","location","hostname","match","store","createStore","compose","applyMiddleware","thunk","DevTools","instrument","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.b5378790.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/clockwise.942198c7.svg\";","module.exports = __webpack_public_path__ + \"static/media/counter-clockwise.d21e64eb.svg\";","module.exports = __webpack_public_path__ + \"static/media/fiene.bd1a0420.png\";","export function byId(array) {\r\n    return array.reduce(\r\n        (byId, element) => (byId[element.id] = element) && byId,\r\n        {}\r\n    );\r\n}\r\n\r\n// Ruby's Array#chunk\r\nexport function chunk(array, func, keepNullOrUndefined = false) {\r\n    if (!Array.isArray(array)) {\r\n        throw new Error(`First argument should be an Array`);\r\n    }\r\n\r\n    if (typeof func !== \"function\") {\r\n        throw new Error(`Second argument should be a Function`);\r\n    }\r\n\r\n    const chunks = array.reduce((chunks, element) => {\r\n        const prev = chunks[chunks.length - 1];\r\n        const [prevValue, prevElements] = prev || [];\r\n\r\n        const newValue = func(element);\r\n\r\n        if (newValue !== prevValue) {\r\n            // This will become a new element\r\n            chunks.push([newValue, [element]]);\r\n        } else {\r\n            // Add to previous\r\n            prevElements.push(element);\r\n        }\r\n\r\n        return chunks;\r\n    }, []);\r\n\r\n    // Filter out any elements of a null or undefined key,\r\n    // unless specified otherwise\r\n    if (keepNullOrUndefined) return chunks;\r\n\r\n    return chunks.filter(chunk => chunk[0] != null);\r\n}\r\n\r\nexport function groupBy(array, func) {\r\n    return array.reduce((grouped, element) => {\r\n        const key = func(element);\r\n        (grouped[key] || (grouped[key] = [])).push(element);\r\n        return grouped;\r\n    }, {});\r\n}\r\n\r\n// Ruby's Array#uniq\r\nexport function uniq(array) {\r\n    return array.reduce((uniques, element) => {\r\n        if (uniques.indexOf(element) === -1) {\r\n            uniques.push(element);\r\n        }\r\n\r\n        return uniques;\r\n    }, []);\r\n}\r\n\r\n// From: http://stackoverflow.com/a/6274381/2858155\r\n// Modified to return new array\r\nexport function shuffle(a) {\r\n    const newA = Array.from(a);\r\n\r\n    var j, x, i;\r\n    for (i = newA.length; i; i--) {\r\n        j = Math.floor(Math.random() * i);\r\n        x = newA[i - 1];\r\n        newA[i - 1] = newA[j];\r\n        newA[j] = x;\r\n    }\r\n\r\n    return newA;\r\n}\r\n\r\nfunction greaterThan(x, y) {\r\n    if (x > y) return 1;\r\n    if (x < y) return -1;\r\n    return 0;\r\n}\r\n\r\nfunction lessThan(x, y) {\r\n    return greaterThan(y, x);\r\n}\r\n\r\nfunction minOrMax(array, operator, compareBy = x => x, transform = x => x) {\r\n    const [mmElement] = array.reduce(\r\n        (mmData, element) => {\r\n            const [, mmValue] = mmData;\r\n            const value = compareBy(element);\r\n\r\n            if (value == null) return mmData;\r\n\r\n            if (mmValue == null || operator(value, mmValue) > 0) {\r\n                return [element, value];\r\n            }\r\n\r\n            return mmData;\r\n        },\r\n        [null, null]\r\n    ); // <= [ mmElement, mmValue ]\r\n\r\n    return transform(mmElement);\r\n}\r\n\r\nfunction max(array, compareBy = x => x, transform = x => x) {\r\n    return minOrMax(array, greaterThan, compareBy, transform);\r\n}\r\n\r\nfunction min(array, compareBy = x => x, transform = x => x) {\r\n    return minOrMax(array, lessThan, compareBy, transform);\r\n}\r\n\r\n// Returns the maximum element, comparing the property obtained\r\n// from calling `maxBy` on each element.\r\nexport function maxElement(array, maxBy = x => x) {\r\n    return max(array, maxBy);\r\n}\r\n\r\n// Returns the maximum value, comparing the property obtained\r\n// from calling `maxBy` on each element returning the maximum\r\n// resulting value\r\nexport function maxValue(array, maxBy) {\r\n    return max(array, maxBy, maxBy);\r\n}\r\n\r\n// Returns the minimum element, comparing the property obtained\r\n// from calling `minBy` on each element.\r\nexport function minElement(array, minBy = x => x) {\r\n    return min(array, minBy);\r\n}\r\n\r\n// Returns the minimum value, comparing the property obtained\r\n// from calling `minBy` on each element returning the minimum\r\n// resulting value\r\nexport function minValue(array, minBy = x => x) {\r\n    return min(array, minBy, minBy);\r\n}\r\n\r\nexport function transpose(array) {\r\n    if (\r\n        !Array.isArray(array) ||\r\n        array.length === 0 ||\r\n        array.some(subArray => !Array.isArray(subArray))\r\n    ) {\r\n        throw new Error(\r\n            `Argument should be an Array of exclusively other Arrays`\r\n        );\r\n    }\r\n\r\n    const maxColSize = maxValue(array, subArray => subArray.length);\r\n\r\n    const transposed = [];\r\n\r\n    for (let col = 0; col < maxColSize; col++) {\r\n        for (let row = 0; row < array.length; row++) {\r\n            (transposed[col] || (transposed[col] = []))[row] = array[row][col];\r\n        }\r\n    }\r\n\r\n    return transposed;\r\n}\r\n","import { createSelector } from \"reselect\";\r\n\r\nexport const getPlayersById = state => state.players;\r\nexport const getActivePlayerId = state => state.activePlayer;\r\nexport const getNextPlayerId = state => state.activePlayer % 2 + 1;\r\n\r\nexport const getPlayers = createSelector(getPlayersById, playersById =>\r\n    Object.keys(playersById).map(id => playersById[id])\r\n);\r\n\r\nexport const getPlayer = playerId =>\r\n    createSelector(getPlayersById, playersById => playersById[playerId]);\r\n\r\nexport const getActivePlayer = createSelector(\r\n    getPlayersById,\r\n    getActivePlayerId,\r\n    (playersById, activePlayerId) => playersById[activePlayerId]\r\n);\r\n\r\nexport const getNextPlayer = createSelector(\r\n    getPlayersById,\r\n    getNextPlayerId,\r\n    (playersById, nextPlayerId) => playersById[nextPlayerId]\r\n);\r\n\r\nexport const getOtherPlayer = playerId =>\r\n    createSelector(\r\n        getPlayersById,\r\n        playersById =>\r\n            playersById[\r\n                Object.keys(playersById).find(k => parseInt(k, 10) !== playerId)\r\n            ]\r\n    );\r\n\r\nexport const activePlayerIsAI = createSelector(\r\n    getActivePlayer,\r\n    player => player.isAI\r\n);\r\n","import randomColor from \"randomcolor\";\r\n\r\nexport const AMOUNT_IN_LINE_TO_WIN = 5;\r\nexport const BOARD_SIZE = 6;\r\nexport const QUADRANT_SIZE = 3;\r\nexport const NUM_QUADRANTS = Math.floor(BOARD_SIZE / QUADRANT_SIZE, 10);\r\n\r\nconst colors = [];\r\nconst hues = [\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"purple\", \"pink\"];\r\nhues.forEach(hue => colors.push(randomColor({ hue, luminosity: \"bright\" })));\r\n\r\nexport const COLORS = colors;\r\n","import { createSelector } from \"reselect\";\r\nimport { chunk, transpose, groupBy } from \"../helpers\";\r\nimport { getPlayers } from \"./playerSelectors\";\r\nimport * as Constants from \"../constants\";\r\n\r\n// The input for all other selectors, make sure this *only* yields\r\n// a new object when the relevant state has actually changed\r\nconst initCells = state => state.cells;\r\n\r\nconst getCells = createSelector(initCells, cellsById =>\r\n    Object.keys(cellsById).map(id => cellsById[id])\r\n);\r\n\r\nexport const getCell = (state, id) => state.cells[id];\r\n\r\nexport const getAvailableCells = createSelector(getCells, cells =>\r\n    cells.filter(cell => cell.player == null)\r\n);\r\n\r\nconst getSortedCells = createSelector(getCells, cells => {\r\n    return cells.sort((x, y) => {\r\n        if (x.row > y.row) return 1;\r\n        if (x.row < y.row) return -1;\r\n\r\n        if (x.col > y.col) return 1;\r\n        if (x.col < y.col) return -1;\r\n\r\n        return 0;\r\n    });\r\n});\r\n\r\nexport const getRows = createSelector(getSortedCells, cells =>\r\n    cells.reduce(\r\n        (rows, cell) =>\r\n            (rows[cell.row] || (rows[cell.row] = [])).push(cell) && rows,\r\n        []\r\n    )\r\n);\r\n\r\nexport const getColumns = createSelector(getSortedCells, cells =>\r\n    cells.reduce(\r\n        (columns, cell) =>\r\n            (columns[cell.col] || (columns[cell.col] = [])).push(cell) &&\r\n            columns,\r\n        []\r\n    )\r\n);\r\n\r\nexport const getDiagonals = createSelector(getSortedCells, cells => {\r\n    const topLeftToBottomRight = groupBy(cells, cell => cell.row - cell.col);\r\n    const bottomLeftToTopRight = groupBy(cells, cell => cell.row + cell.col);\r\n\r\n    return [\r\n        topLeftToBottomRight,\r\n        bottomLeftToTopRight\r\n    ].reduce((diagonals, collectionOfDiagonals) => {\r\n        for (let key of Object.keys(collectionOfDiagonals)) {\r\n            const diagonal = collectionOfDiagonals[key];\r\n            diagonals.push(diagonal);\r\n        }\r\n        return diagonals;\r\n    }, []);\r\n});\r\n\r\nfunction findWinningCellsInLines(lines, player) {\r\n    if (!player) return null;\r\n\r\n    for (let line of lines) {\r\n        const winningCells = winsInLine(line, player);\r\n        if (winningCells) return winningCells;\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport const getWinningCellsByPlayer = createSelector(\r\n    getRows,\r\n    getColumns,\r\n    getDiagonals,\r\n    getPlayers,\r\n    (rows, columns, diagonals, players) => {\r\n        const winningCellsByPlayer = {};\r\n\r\n        const lines = [...rows, ...columns, ...diagonals];\r\n\r\n        for (let player of players) {\r\n            winningCellsByPlayer[player.id] = findWinningCellsInLines(\r\n                lines,\r\n                player.id\r\n            );\r\n        }\r\n\r\n        return winningCellsByPlayer;\r\n    }\r\n);\r\n\r\nfunction winsInLine(line, player) {\r\n    return chunk(line, cell => cell.player === player)\r\n        .filter(chunk => chunk[0])\r\n        .map(chunk => chunk[1])\r\n        .find(cells => cells.length >= Constants.AMOUNT_IN_LINE_TO_WIN);\r\n}\r\n\r\nconst quadrantMinAndMaxRowOrCol = rowOrCol => [\r\n    rowOrCol * Constants.QUADRANT_SIZE,\r\n    (rowOrCol + 1) * Constants.QUADRANT_SIZE - 1\r\n];\r\n\r\nconst quadrantMinAndMaxRow = row => quadrantMinAndMaxRowOrCol(row);\r\nconst quadrantMinAndMaxCol = col => quadrantMinAndMaxRowOrCol(col);\r\n\r\nfunction getQuadrant(row, col, cells) {\r\n    const [minRow, maxRow] = quadrantMinAndMaxRow(row);\r\n    const [minCol, maxCol] = quadrantMinAndMaxCol(col);\r\n\r\n    const cellsOfQuadrant = cells.filter(\r\n        cell =>\r\n            cell.row >= minRow &&\r\n            cell.row <= maxRow &&\r\n            cell.col >= minCol &&\r\n            cell.col <= maxCol\r\n    );\r\n\r\n    return chunk(cellsOfQuadrant, cell => cell.row).map(chunk => chunk[1]);\r\n}\r\n\r\nexport const makeGetQuadrant = (row, col) =>\r\n    createSelector(getSortedCells, cells => getQuadrant(row, col, cells));\r\n\r\n// Returns the quadrants in an Array\r\nexport const getQuadrants = createSelector(getSortedCells, cells => {\r\n    const quadrants = [];\r\n\r\n    for (let r = 0; r < Constants.NUM_QUADRANTS; r++) {\r\n        for (let c = 0; c < Constants.NUM_QUADRANTS; c++) {\r\n            quadrants.push(getQuadrant(r, c, cells));\r\n        }\r\n    }\r\n\r\n    return quadrants;\r\n});\r\n\r\n// Returns the quadrants in a 2D Array (i.e., in rows and columns)\r\nexport const getQuadrants2D = createSelector(getSortedCells, cells => {\r\n    const quadrants = [];\r\n\r\n    for (let r = 0; r < Constants.NUM_QUADRANTS; r++) {\r\n        const row = [];\r\n\r\n        for (let c = 0; c < Constants.NUM_QUADRANTS; c++) {\r\n            row.push(getQuadrant(r, c, cells));\r\n        }\r\n\r\n        quadrants.push(row);\r\n    }\r\n\r\n    return quadrants;\r\n});\r\n\r\nfunction rotateClockwise(quadrant) {\r\n    return transpose(quadrant.reverse());\r\n}\r\n\r\nfunction rotateCounterclockwise(quadrant) {\r\n    return transpose(quadrant.map(row => row.reverse()));\r\n}\r\n\r\nfunction rotate(quadrant, turnClockwise) {\r\n    return (turnClockwise ? rotateClockwise : rotateCounterclockwise)(quadrant);\r\n}\r\n\r\n// Returns copied cells, does not actually modify the cells of this state\r\nexport const makeGetRotatedQuadrant = (row, column, clockwise) =>\r\n    createSelector(makeGetQuadrant(row, column), quadrant => {\r\n        // Apply rotation\r\n        const rotated = rotate(quadrant, clockwise);\r\n\r\n        const [minRow] = quadrantMinAndMaxRow(row);\r\n        const [minCol] = quadrantMinAndMaxCol(column);\r\n\r\n        // Return a flat object of cell id => cell,\r\n        // where we have updated .row and .col of each cell\r\n        // accordingly to its new position in the quadrant\r\n        // which is currently only represented by the index\r\n        const cells = {};\r\n\r\n        for (let irow = 0; irow < rotated.length; irow++) {\r\n            const row = rotated[irow];\r\n            for (let icol = 0; icol < row.length; icol++) {\r\n                const cell = rotated[irow][icol];\r\n\r\n                cells[cell.id] = Object.assign({}, cell, {\r\n                    row: irow + minRow,\r\n                    col: icol + minCol\r\n                });\r\n            }\r\n        }\r\n\r\n        return cells;\r\n    });\r\n\r\nexport const getMetadata = createSelector(\r\n    getPlayers,\r\n    getRows,\r\n    getColumns,\r\n    getDiagonals,\r\n    (players, rows, columns, diagonals) => {\r\n        const cellsInLine = [...rows, ...columns, ...diagonals];\r\n        const metadata = {};\r\n\r\n        for (let player of players) {\r\n            const potentials = {};\r\n\r\n            for (let line of cellsInLine) {\r\n                const potentialAmountInLine = computePotentialsInLine(\r\n                    line,\r\n                    player\r\n                );\r\n                if (\r\n                    !potentialAmountInLine ||\r\n                    potentialAmountInLine.length === 0\r\n                )\r\n                    continue;\r\n\r\n                for (let group of potentialAmountInLine) {\r\n                    (potentials[group.length] ||\r\n                        (potentials[group.length] = []))\r\n                        .push(group);\r\n                }\r\n            }\r\n\r\n            metadata[player.id] = potentials;\r\n        }\r\n\r\n        return metadata;\r\n    }\r\n);\r\n\r\nfunction computePotentialsInLine(line, player) {\r\n    const maxInLine = maxAdjacentsInLine(line, player);\r\n    // If the maximum amount is not enough to win\r\n    // there's no potential whatsoever, line should be totally ignored.\r\n    if (maxInLine < Constants.AMOUNT_IN_LINE_TO_WIN) return null;\r\n\r\n    // Chunk by empty or owned by player, drops opponents cells\r\n    const chunks = chunk(\r\n        line,\r\n        cell =>\r\n            cell.player == null || (cell.player === player.id ? false : null)\r\n    );\r\n\r\n    return chunks.reduce((groups, chunk) => {\r\n        const [isEmpty, cells] = chunk;\r\n\r\n        // TODO: Fix this can occur at all (bug in chunk method when last element becomes null)\r\n        // if(!cells) return groups;\r\n\r\n        const firstCell = cells[0];\r\n        const firstIdx = line.indexOf(firstCell);\r\n        const lastCell = cells[cells.length - 1];\r\n\r\n        const isLastAndEmpty =\r\n            isEmpty && chunks.indexOf(chunk) === chunks.length - 1;\r\n\r\n        const prevGroup = groups[groups.length - 1];\r\n\r\n        // No previous group, add yourself and be done\r\n        if (!prevGroup) {\r\n            if (!isLastAndEmpty) {\r\n                groups.push(cells);\r\n            }\r\n        } else {\r\n            const prevGroupIsEmpty = prevGroup.every(\r\n                cell => cell.player == null\r\n            );\r\n            let prevLastCell = prevGroup[prevGroup.length - 1];\r\n            let prevLastIdx = line.indexOf(prevLastCell);\r\n\r\n            let distance = Math.abs(firstIdx - prevLastIdx);\r\n\r\n            // If we are not adjacent, we can't join them\r\n            if (distance > 1) {\r\n                // However, make sure to remove the previous group\r\n                // if it was completely empty\r\n                if (prevGroupIsEmpty) {\r\n                    groups.pop();\r\n                }\r\n\r\n                // And add ourself so other cells can join up later\r\n                if (!isLastAndEmpty) {\r\n                    groups.push(cells);\r\n                }\r\n            } else {\r\n                // Empty cells, first cell will try to join the previous group\r\n                if (isEmpty) {\r\n                    // If the previous group is completely empty, remove it (it's irrelevant)\r\n                    if (prevGroupIsEmpty) {\r\n                        groups.pop();\r\n\r\n                        // Add ourselves, but not if we are the last empty group\r\n                        if (!isLastAndEmpty) {\r\n                            groups.push(cells);\r\n                        }\r\n                    } else {\r\n                        // This group belongs to the player, we join it with our first cell,\r\n                        // _only if_ it does not have an empty cell yet\r\n                        if (!prevGroup.some(cell => cell.player == null)) {\r\n                            // Cool, let's join them\r\n                            prevGroup.push(firstCell);\r\n                        } else {\r\n                            // It already has merged with some other empty cell\r\n                            // We instead duplicate it and create a new group\r\n                            // First we drop all cells upto the empty cell and then the empty cell itself\r\n                            const emptyIdx = prevGroup.findIndex(\r\n                                cell => cell.player == null\r\n                            );\r\n                            groups.push([\r\n                                ...prevGroup.slice(emptyIdx + 1),\r\n                                firstCell\r\n                            ]);\r\n                        }\r\n\r\n                        // We only add ourselves when firstCell is different from lastCell\r\n                        // If firstCell is the same as lastCell, the next group can just join\r\n                        // us in the previous group.\r\n                        // Again, do not add ourselves if we are the last group and empty\r\n                        if (firstCell !== lastCell && !isLastAndEmpty) {\r\n                            groups.push(cells);\r\n                        }\r\n                    }\r\n                } else {\r\n                    // Player controlled cells\r\n                    // Try to join a previous player-controlled group\r\n                    // It can have most have 1 empty cell but that's fine\r\n                    if (prevGroup.some(cell => cell.player != null)) {\r\n                        for (let cell of cells) {\r\n                            prevGroup.push(cell);\r\n                        }\r\n                    } else {\r\n                        // Previous group is entirely empty\r\n                        // Grab their last cell and put it in a new group,\r\n                        // remove the empty group\r\n                        groups.pop();\r\n                        groups.push([prevLastCell, ...cells]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return groups;\r\n    }, []);\r\n}\r\n\r\nfunction maxAdjacentsInLine(line, player) {\r\n    // Chunk line into Arrays containing adjacent spots\r\n    // that are empty or belong to player\r\n    const chunks = chunk(\r\n        line,\r\n        cell => (cell.player != null && cell.player !== player.id ? null : true)\r\n    );\r\n    return chunks\r\n        .map(chunk => chunk[1])\r\n        .reduce(\r\n            (max, chunk) => (chunk && chunk.length > max ? chunk.length : max),\r\n            0\r\n        );\r\n}\r\n\r\nfunction scoreForPlayer(rows, metadata, player) {\r\n    const scoreSystemPotentials = {\r\n        2: 1,\r\n        3: 10,\r\n        4: 100,\r\n        5: 1000,\r\n        6: 10000,\r\n\r\n        fillQuadrantMultiplier: 4,\r\n        noFriendliesAround: 0.25\r\n    };\r\n\r\n    const score = {\r\n        points: 0,\r\n        wins: false\r\n    };\r\n\r\n    // Score for potential cells in a line\r\n    const keys = Object.keys(metadata[player.id]).map(k => parseInt(k, 10));\r\n    for (let n of keys) {\r\n        let base = scoreSystemPotentials[n];\r\n\r\n        const chunkedCells = metadata[player.id][n];\r\n\r\n        for (let group of chunkedCells) {\r\n            let multiplier = 1;\r\n\r\n            const emptyCell = group.find(cell => cell.player == null);\r\n\r\n            // No emptyCell means it's not a potential of n, but it already IS n,\r\n            // the line is simply not longer. So increase our base accordingly.\r\n            if (!emptyCell) {\r\n                base = scoreSystemPotentials[n + 1];\r\n            } else {\r\n                const qSize = Constants.QUADRANT_SIZE;\r\n                const cellsByQuadrant = chunk(\r\n                    group,\r\n                    cell =>\r\n                        `${Math.floor(cell.row / qSize)}${Math.floor(\r\n                            cell.col / qSize\r\n                        )}`\r\n                ).map(chunk => chunk[1]);\r\n\r\n                // Empty cell completed a quadrant if the group it is part of is the length of a quadrant\r\n                const groupOfEmptyCell = cellsByQuadrant.find(\r\n                    cells => cells.indexOf(emptyCell) > -1\r\n                );\r\n                const completesQuadrant =\r\n                    groupOfEmptyCell.length === Constants.QUADRANT_SIZE;\r\n\r\n                if (completesQuadrant) {\r\n                    multiplier *= scoreSystemPotentials.fillQuadrantMultiplier;\r\n                }\r\n\r\n                // If the empty cell is not surrounded by any friendly cells in its quadrant,\r\n                // impose a big penalty (experimental)\r\n                const surroundingCells = getSurroundingCells(emptyCell, rows);\r\n                const quadrantOfEmptyCell = getQuadrantId(emptyCell);\r\n                if (\r\n                    !surroundingCells.some(\r\n                        cell =>\r\n                            getQuadrantId(cell) === quadrantOfEmptyCell &&\r\n                            cell.player === player.id\r\n                    )\r\n                ) {\r\n                    multiplier *= scoreSystemPotentials.noFriendliesAround;\r\n                }\r\n            }\r\n\r\n            score.points += base * multiplier;\r\n\r\n            // If n > AMOUNT_TO_WIN, we have actually already won ;)\r\n            if (\r\n                n > Constants.AMOUNT_IN_LINE_TO_WIN ||\r\n                (n === Constants.AMOUNT_IN_LINE_TO_WIN && !emptyCell)\r\n            ) {\r\n                score.wins = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Score for individual cells\r\n    const scoreSystemCells = {\r\n        none: -1, // Cells at the edge\r\n        opponent: 0,\r\n        empty: 1,\r\n        mine: 4,\r\n        sameQuadrantMultiplier: 1.5\r\n    };\r\n\r\n    for (let r = 0; r < rows.length; r++) {\r\n        const row = rows[r];\r\n\r\n        for (let c = 0; c < row.length; c++) {\r\n            const cell = row[c];\r\n\r\n            // Only score my cells\r\n            if (cell.player == null || cell.player !== player.id) continue;\r\n\r\n            const cellQuadrantId = getQuadrantId(cell);\r\n            const surroundingCells = getSurroundingCells(cell, rows);\r\n\r\n            // A cell has at most (QUADRANT_SIZE ^ 2) - 1 surrounding cells\r\n            // Any missing cell will score scoreSystemCells.none points\r\n            const missingCells =\r\n                Constants.QUADRANT_SIZE * Constants.QUADRANT_SIZE -\r\n                surroundingCells.length;\r\n            score.points += missingCells * scoreSystemCells.none;\r\n\r\n            for (let otherCell of surroundingCells) {\r\n                const otherCellQuadrantId = getQuadrantId(otherCell);\r\n                const isSameQuadrant = cellQuadrantId === otherCellQuadrantId;\r\n                const multiplier = isSameQuadrant\r\n                    ? scoreSystemCells.sameQuadrantMultiplier\r\n                    : 1;\r\n\r\n                if (otherCell.player == null) {\r\n                    // Empty cell\r\n                    score.points += scoreSystemCells.empty * multiplier;\r\n                } else if (otherCell.player === player.id) {\r\n                    // Mine\r\n                    score.points += scoreSystemCells.mine * multiplier;\r\n                } else if (otherCell.player !== player.id) {\r\n                    // Opponent\r\n                    score.points += scoreSystemCells.opponent;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return score;\r\n}\r\n\r\n// Yields all cells that surround the given cell\r\nfunction getSurroundingCells(cell, rows) {\r\n    // dx / dy of surrounding cells\r\n    const coords = [\r\n        { row: cell.row, col: cell.col - 1 }, // left\r\n        { row: cell.row, col: cell.col + 1 }, // right\r\n        { row: cell.row - 1, col: cell.col }, // top\r\n        { row: cell.row + 1, col: cell.col }, // bottom\r\n        { row: cell.row - 1, col: cell.col - 1 }, // topleft\r\n        { row: cell.row - 1, col: cell.col + 1 }, // topright\r\n        { row: cell.row + 1, col: cell.col - 1 }, // bottomleft\r\n        { row: cell.row + 1, col: cell.col + 1 } // bottomright\r\n    ];\r\n\r\n    // Return those that exist\r\n    return coords.reduce((cells, possibleCell) => {\r\n        const { row, col } = possibleCell;\r\n        // Does it exist?\r\n        if (\r\n            row >= 0 &&\r\n            row < Constants.BOARD_SIZE &&\r\n            col >= 0 &&\r\n            col < Constants.BOARD_SIZE\r\n        ) {\r\n            cells.push(rows[row][col]);\r\n        }\r\n\r\n        return cells;\r\n    }, []);\r\n}\r\n\r\nexport const getBoardScoreByPlayer = createSelector(\r\n    getRows,\r\n    getMetadata,\r\n    getPlayers,\r\n    (rows, metadata, players) => {\r\n        const playerScores = {};\r\n\r\n        for (let player of players) {\r\n            playerScores[player.id] = scoreForPlayer(rows, metadata, player);\r\n        }\r\n\r\n        // This is a 2 player game\r\n        const playerOne = players[0];\r\n        const playerTwo = players[1];\r\n\r\n        const playerOnePoints = playerScores[playerOne.id].points;\r\n        const playerOneWins = playerScores[playerOne.id].wins;\r\n\r\n        const playerTwoPoints = playerScores[playerTwo.id].points;\r\n        const playerTwoWins = playerScores[playerTwo.id].wins;\r\n\r\n        return {\r\n            [playerOne.id]: {\r\n                points: playerOnePoints - playerTwoPoints,\r\n                pointsOne: playerOnePoints,\r\n                wins: playerOneWins\r\n            },\r\n            [playerTwo.id]: {\r\n                points: playerTwoPoints - playerOnePoints,\r\n                pointsTwo: playerTwoPoints,\r\n                wins: playerTwoWins\r\n            }\r\n        };\r\n    }\r\n);\r\n\r\n// Yields the ID of the cell's quadrant (0-based index, row to column)\r\nexport function getQuadrantId(cell) {\r\n    const qRow = Math.floor(cell.row / Constants.QUADRANT_SIZE);\r\n    const qCol = Math.floor(cell.col / Constants.QUADRANT_SIZE);\r\n\r\n    return qRow * Constants.NUM_QUADRANTS + qCol;\r\n}\r\n\r\n// Yields the Quadrant of the given cellId as { row: ..., column: ... }\r\nexport function getQuadrantRowAndColumn(state, cellId) {\r\n    const cell = getCell(state, cellId);\r\n\r\n    const row = Math.floor(cell.row / Constants.QUADRANT_SIZE);\r\n    const column = Math.floor(cell.col / Constants.QUADRANT_SIZE);\r\n\r\n    return { row, column };\r\n}\r\n","import { tryPickCell, rotateQuadrant, animateQuadrant } from \"./index\";\r\nimport {\r\n    getQuadrants,\r\n    getAvailableCells,\r\n    makeGetRotatedQuadrant,\r\n    getMetadata,\r\n    getBoardScoreByPlayer,\r\n    getQuadrantId\r\n} from \"../selectors/cellSelectors\";\r\nimport {\r\n    getActivePlayer,\r\n    getNextPlayer,\r\n    getPlayer,\r\n    getOtherPlayer\r\n} from \"../selectors/playerSelectors\";\r\nimport { chunk, maxElement, shuffle } from \"../helpers\";\r\nimport * as Constants from \"../constants\";\r\n\r\nlet boards = [\r\n    // {\r\n    //   cells: [],\r\n    //   rotation: { row: ..., column: ..., clockwise: ... },\r\n    //   metadata: {}\r\n    // }\r\n];\r\n\r\nlet currentPlayer;\r\nlet nextPlayer;\r\n\r\nexport function computeMove(showMove = true) {\r\n    return (dispatch, getState) => {\r\n        const state = getState();\r\n\r\n        // Game has already ended\r\n        if (state.gameOver) return { cellId: null, rotation: null };\r\n\r\n        currentPlayer = getActivePlayer(state);\r\n        nextPlayer = getNextPlayer(state);\r\n\r\n        boards = getBoards(getState);\r\n\r\n        // It is possible we have already picked a cell,\r\n        // if we were controlled by a human who picked one\r\n        // and then switched to being controlled by AI\r\n        // In that case, just pick the optimal rotation\r\n        let moveData = null;\r\n        if (!state.canPickCell) {\r\n            moveData = { rotation: optimalRotation(getState) };\r\n        } else {\r\n            // Cell + rotation\r\n            for (let moveFunction of optimalMovesInOrder) {\r\n                // console.log(`${currentPlayer.name}: Trying ${moveFunction.name}`);\r\n                moveData = moveFunction(getState);\r\n                if (moveData != null) {\r\n                    // console.log(`${currentPlayer.name}: Picked ${moveFunction.name}`);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Shows the move on the board (without actually doing the move)\r\n        if (showMove) {\r\n            dispatch(computedMove(moveData));\r\n        }\r\n\r\n        return moveData;\r\n    };\r\n}\r\n\r\nexport const COMPUTED_MOVE = \"COMPUTED_MOVE\";\r\nexport function computedMove(move) {\r\n    return {\r\n        type: COMPUTED_MOVE,\r\n        move: move\r\n    };\r\n}\r\n\r\nexport const HIDE_COMPUTED_MOVE = \"HIDE_COMPUTED_MOVE\";\r\nexport function hideComputedMove() {\r\n    return {\r\n        type: HIDE_COMPUTED_MOVE\r\n    };\r\n}\r\n\r\nexport function computeAndDoMove() {\r\n    return (dispatch, getState) => {\r\n        const state = getState();\r\n\r\n        // If we had already computed a move this turn,\r\n        // use that instead of computing a new one again\r\n        const { cellId, rotation } =\r\n            state.ui.computedMove || computeMove(false)(dispatch, getState);\r\n\r\n        let gameOver = false;\r\n\r\n        if (cellId != null) {\r\n            gameOver = dispatch(tryPickCell(cellId, currentPlayer.id));\r\n        }\r\n\r\n        // It is possible to have an AI do only a rotation\r\n        // when we switch a player to AI after picking a cell,\r\n        // therefore the rotation is not nested after picking the cell\r\n        if (!gameOver && rotation != null) {\r\n            const { row, column, clockwise } = rotation;\r\n\r\n            // Rotation (only if we haven't won by placing the cell)\r\n            if (state.options.animationsEnabled) {\r\n                dispatch(animateQuadrant(row, column, clockwise));\r\n            } else {\r\n                dispatch(rotateQuadrant(row, column, clockwise));\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n// Build the 9 different boards (non-rotation and 8 rotations)\r\n// and compute their metadata\r\nfunction getBoards(getState) {\r\n    const boards = [];\r\n\r\n    // The current, non-rotated board\r\n    boards.push(initBoard(getState));\r\n\r\n    // All rotations of a single quadrant\r\n    for (let row = 0; row < Constants.NUM_QUADRANTS; row++) {\r\n        for (let column = 0; column < Constants.NUM_QUADRANTS; column++) {\r\n            for (let clockwise of [true, false]) {\r\n                const rotation = { row, column, clockwise };\r\n                boards.push(initBoard(getState, rotation));\r\n            }\r\n        }\r\n    }\r\n\r\n    return boards;\r\n}\r\n\r\nfunction initBoard(getState, rotation) {\r\n    const state = getState();\r\n\r\n    let cells;\r\n\r\n    if (rotation) {\r\n        const rotatedCells = makeGetRotatedQuadrant(\r\n            rotation.row,\r\n            rotation.column,\r\n            rotation.clockwise\r\n        )(state);\r\n        cells = Object.assign({}, state.cells, rotatedCells);\r\n    } else {\r\n        cells = Object.assign({}, state.cells);\r\n    }\r\n\r\n    const newState = Object.assign({}, state, {\r\n        cells: Object.assign({}, state.cells, cells)\r\n    });\r\n\r\n    const metadata = computeMetadata(() => newState);\r\n\r\n    return {\r\n        cells,\r\n        metadata,\r\n        rotation\r\n    };\r\n}\r\n\r\nconst optimalMovesInOrder = [\r\n    winningMove,\r\n    preventWinningMove,\r\n\r\n    lineInQuadrant,\r\n    preventLineInQuadrant,\r\n\r\n    makeLine4,\r\n    preventMakeLine4,\r\n\r\n    // setupMultipleLinesInQuadrant,\r\n\r\n    inCenter,\r\n    adjacentToSelf,\r\n    randomCell\r\n];\r\n\r\nfunction getBoard(rotation) {\r\n    const { row, column, clockwise } = rotation;\r\n\r\n    return boards.find(\r\n        board =>\r\n            board.rotation === rotation ||\r\n            (board.rotation != null &&\r\n                board.rotation.row === row &&\r\n                board.rotation.column === column &&\r\n                board.rotation.clockwise === clockwise)\r\n    );\r\n}\r\n\r\nfunction makeLine(\r\n    getState,\r\n    {\r\n        player = currentPlayer, // Search for a line with the given arguments for this player\r\n        doAsPlayer = currentPlayer, // This player will actually do the move, and we will do it optimally for this player\r\n        min = 3,\r\n        requiresFullQuadrant = false,\r\n        requiresRotation = true,\r\n        boardsToConsider = boards,\r\n        lookahead = true // Look ahead 1 move of rotations\r\n    } = {}\r\n) {\r\n    let optimal = {\r\n        score: null,\r\n        cellId: null,\r\n        rotation: null\r\n    };\r\n\r\n    for (let board of boardsToConsider) {\r\n        const rotation = board.rotation;\r\n\r\n        // Only look at rotations, if required\r\n        if (!rotation && requiresRotation) continue;\r\n\r\n        let meta = board.metadata[player.id];\r\n\r\n        if (requiresFullQuadrant) {\r\n            // Filter out any potential cells that\r\n            // do not at least fill a quadrant\r\n            const keys = Object.keys(meta);\r\n            const newMeta = {};\r\n\r\n            for (let key of keys) {\r\n                const potentials = meta[key];\r\n\r\n                for (let group of potentials) {\r\n                    const emptyCell = group.find(cell => cell.player == null);\r\n\r\n                    const qSize = Constants.QUADRANT_SIZE;\r\n                    const cellsByQuadrant = chunk(\r\n                        group,\r\n                        cell =>\r\n                            `${Math.floor(cell.row / qSize)}${Math.floor(\r\n                                cell.col / qSize\r\n                            )}`\r\n                    ).map(chunk => chunk[1]);\r\n                    // Empty cell completed a quadrant if the group it is part of is the length of a quadrant\r\n                    const groupOfEmptyCell = cellsByQuadrant.find(\r\n                        cells => cells.indexOf(emptyCell) > -1\r\n                    );\r\n                    const completesQuadrant =\r\n                        groupOfEmptyCell &&\r\n                        groupOfEmptyCell.length === Constants.QUADRANT_SIZE;\r\n\r\n                    // Fills a quadrant? Then we include it\r\n                    if (completesQuadrant) {\r\n                        (newMeta[key] || (newMeta[key] = [])).push(group);\r\n                    }\r\n                }\r\n            }\r\n\r\n            meta = newMeta;\r\n        }\r\n\r\n        const key = maxElement(Object.keys(meta).filter(key => key >= min));\r\n        let cell = null;\r\n        let cells = null;\r\n        if (key) {\r\n            // Introduce a bit of randomness\r\n            const metaCopy = shuffle(meta[key]);\r\n\r\n            cells = maxElement(metaCopy, group => {\r\n                const emptyCell = group.find(cell => cell.player == null);\r\n                if (!emptyCell) return null;\r\n\r\n                // State with current rotated cells\r\n                // and possibly the given cell\r\n                const state = Object.assign({}, getState(), {\r\n                    cells: Object.assign({}, board.cells, {\r\n                        [emptyCell.id]: Object.assign(\r\n                            {},\r\n                            board.cells[emptyCell.id],\r\n                            { player: doAsPlayer.id }\r\n                        )\r\n                    })\r\n                });\r\n\r\n                const score = getBoardScoreByPlayer(state);\r\n\r\n                return score[doAsPlayer.id].points;\r\n            });\r\n\r\n            cell = cells && cells.find(cell => cell.player == null);\r\n        }\r\n\r\n        if (cell) {\r\n            // State with current rotated cells\r\n            // and possibly the given cell\r\n            const state = Object.assign({}, getState(), {\r\n                cells: Object.assign({}, board.cells, {\r\n                    [cell.id]: Object.assign({}, board.cells[cell.id], {\r\n                        player: doAsPlayer.id\r\n                    })\r\n                })\r\n            });\r\n\r\n            const score = getBoardScoreByPlayer(state)[doAsPlayer.id];\r\n            const points = score.points;\r\n            const playerWins = score.wins;\r\n\r\n            // if(lookahead && !playerWins && player.id === doAsPlayer.id) {\r\n            //   const boards = getBoards(() => state);\r\n            //   const opponentWins = winningMove(() => state, { player: getOtherPlayer(doAsPlayer.id)(state), doAsPlayer: getOtherPlayer(doAsPlayer.id)(state), boardsToConsider: boards, lookahead: false });\r\n\r\n            //   if(opponentWins) {\r\n            //     // Cancel plans\r\n            //     console.log(\"DONT DO IT!\");\r\n            //     continue;\r\n            //   }\r\n            // }\r\n\r\n            if (\r\n                optimal.score == null ||\r\n                points > optimal.score ||\r\n                (points === optimal.score && Math.random() > 0.5)\r\n            ) {\r\n                optimal = {\r\n                    cellId: cell.id,\r\n                    score: points,\r\n                    rotation\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    if (optimal.cellId != null) {\r\n        return {\r\n            cellId: optimal.cellId,\r\n            rotation: optimal.rotation\r\n        };\r\n    }\r\n}\r\n\r\nfunction winningMove(\r\n    getState,\r\n    { player = currentPlayer, boardsToConsider = boards, lookahead = true } = {}\r\n) {\r\n    return makeLine(getState, {\r\n        min: Constants.AMOUNT_IN_LINE_TO_WIN,\r\n        player,\r\n        requiresRotation: false,\r\n        boardsToConsider,\r\n        lookahead\r\n    });\r\n}\r\n\r\nfunction preventWinningMove(getState) {\r\n    // First check if the opponent can win without rotating.\r\n    // If that is the case, we have to block the winning cell\r\n    // as rotating away can simply be undone by our opponent\r\n    let { cellId } =\r\n        winningMove(getState, {\r\n            player: nextPlayer,\r\n            doAsPlayer: currentPlayer,\r\n            boardsToConsider: boards.filter(board => !board.rotation)\r\n        }) || {};\r\n\r\n    if (cellId == null) {\r\n        return preventWithOptimalRotation(winningMove, getState);\r\n    } else {\r\n        // We found a winning cell to block,\r\n        // now just find an optimal rotation\r\n        return {\r\n            cellId,\r\n            rotation: optimalRotation(getState, cellId)\r\n        };\r\n    }\r\n}\r\n\r\nfunction makeLine4(getState, { player = currentPlayer } = {}) {\r\n    return makeLine(getState, { min: 4, player });\r\n}\r\n\r\nfunction preventMakeLine4(getState) {\r\n    return preventWithOptimalRotation(makeLine4, getState);\r\n}\r\n\r\nfunction preventWithOptimalRotation(func, getState, options) {\r\n    const move = func(\r\n        getState,\r\n        Object.assign({}, options, { player: nextPlayer })\r\n    );\r\n    if (!move) return null;\r\n\r\n    const { cellId } = move;\r\n\r\n    return {\r\n        cellId,\r\n        rotation: optimalRotation(getState, cellId)\r\n    };\r\n}\r\n\r\n// Will try get a setup in 1 quadrant similar to this:\r\n// | X | X |  |\r\n// +---+---+--+\r\n// | X |   |  |\r\n// +---+---+--+\r\n// |   |   |  |\r\n// +---+---+--+\r\n// i.e. it can always get 3 in a line in a quadrant\r\n// on the next turn, since there are 2 options here\r\nfunction setupMultipleLinesInQuadrant(\r\n    getState,\r\n    { player = currentPlayer } = {}\r\n) {\r\n    // We do NOT have to go through all rotations\r\n    // at first, since we are looking for a setup inside\r\n    // a single quadrant, rotating a quadrant will not\r\n    // have a meaningful influence\r\n\r\n    // First attempt: brute-force it\r\n    // This might not be to bad since there are no\r\n    // rotations involved and we brute-force on\r\n    // a relatively small set of the board to begin with\r\n    // -- all potential <quadrant_size - 1> in a line\r\n    // that are part of the same quadrant\r\n    const board = boards[0];\r\n\r\n    let meta = board.metadata[player.id];\r\n    let setups = meta[Constants.QUADRANT_SIZE - 1];\r\n\r\n    // No setups of the right size at all\r\n    if (!setups) return null;\r\n\r\n    // Select only those with all cells in the same quadrant\r\n    setups = setups.filter(cells =>\r\n        cells.every(cell => {\r\n            const quadrant = getQuadrantId(cell);\r\n            return cells.every(c => quadrant === getQuadrantId(c));\r\n        })\r\n    );\r\n\r\n    // For each group of cells, place a marble in the empty spot\r\n    // and check if this leads to any potential lines that fill the whole quadrant\r\n\r\n    const optimal = { cellId: null, amount: null };\r\n\r\n    for (let cells of setups) {\r\n        const cell = cells.find(cell => cell.player == null);\r\n\r\n        // State with current rotated cells\r\n        // and possibly the given cell\r\n        const state = Object.assign({}, getState(), {\r\n            cells: Object.assign({}, board.cells, {\r\n                [cell.id]: Object.assign({}, board.cells[cell.id], {\r\n                    player: player.id\r\n                })\r\n            })\r\n        });\r\n\r\n        const newMeta = getMetadata(state)[player.id];\r\n\r\n        // Does this move lead to potential full quadrant lines?\r\n        if (newMeta[Constants.QUADRANT_SIZE]) {\r\n            const fullQuadrantLines = newMeta[\r\n                Constants.QUADRANT_SIZE\r\n            ].filter(cells =>\r\n                cells.every(cell => {\r\n                    const quadrant = getQuadrantId(cell);\r\n                    return cells.every(c => quadrant === getQuadrantId(c));\r\n                })\r\n            );\r\n\r\n            if (fullQuadrantLines.length > 1) {\r\n                if (\r\n                    optimal.amount == null ||\r\n                    fullQuadrantLines.length > optimal.amount\r\n                ) {\r\n                    optimal.cellId = cell.id;\r\n                    optimal.amount = fullQuadrantLines.length;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Found a good one\r\n    if (optimal.cellId != null) {\r\n        return {\r\n            cellId: optimal.cellId,\r\n            // The rotation is irrelevant for this specific move\r\n            // so let's make sure we do the best one :)\r\n            rotation: optimalRotation(getState, optimal.cellId)\r\n        };\r\n    }\r\n\r\n    // No luck\r\n    return null;\r\n}\r\n\r\nfunction lineInQuadrant(getState, { player = currentPlayer } = {}) {\r\n    return makeLine(getState, { player, requiresFullQuadrant: true });\r\n}\r\n\r\nfunction preventLineInQuadrant(getState) {\r\n    return makeLine(getState, {\r\n        player: nextPlayer,\r\n        doAsPlayer: currentPlayer,\r\n        requiresFullQuadrant: true\r\n    });\r\n\r\n    // return preventWithOptimalRotation(lineInQuadrant, getState);\r\n}\r\n\r\nfunction inCenter(getState, player = currentPlayer.id) {\r\n    const rotation = optimalRotation(getState);\r\n\r\n    const board = getBoard(rotation);\r\n    const quadrants = getQuadrants({ cells: board.cells });\r\n\r\n    // Pick any of the quadrant centers of that board,\r\n    // preferably horizontally or vertically from\r\n    // on of the other centers that we already have\r\n    // rather than diagonally.\r\n\r\n    // The center is simply the middle cell of each quadrant\r\n    // This assumes the quadrant size is an odd number (obviously)\r\n    // otherwise there is no center :-)\r\n    const centers = quadrants.map(\r\n        q => q[Math.floor(q.length / 2)][Math.floor(q.length / 2)]\r\n    );\r\n\r\n    const playerCenters = centers.filter(\r\n        center => player != null && center.player === player\r\n    );\r\n    const availableCenters = centers.filter(center => center.player == null);\r\n\r\n    if (availableCenters.length > 0) {\r\n        // Prefer a center that is horizontally or vertically\r\n        // from one of the centers you already have, I believe it provides\r\n        // more options than diagonal centers due to more rotations towards\r\n        // each other (4 vs 2)\r\n        const cells = availableCenters.filter(\r\n            c =>\r\n                playerCenters.length === 0 ||\r\n                playerCenters.some(cc => c.row === cc.row || c.col === cc.col)\r\n        );\r\n\r\n        // Pick a random one from the good cells\r\n        let cell = cells[Math.floor(Math.random() * cells.length)];\r\n\r\n        // If no horizontal / vertical center is available, just choose one\r\n        cell =\r\n            cell ||\r\n            availableCenters[\r\n                Math.floor(Math.random() * availableCenters.length)\r\n            ];\r\n\r\n        return {\r\n            cellId: cell.id,\r\n            rotation\r\n        };\r\n    }\r\n\r\n    // None available\r\n    return null;\r\n}\r\n\r\nfunction adjacentToSelf(getState) {\r\n    return makeLine(getState, { min: 2 });\r\n}\r\n\r\nfunction randomCell(getState) {\r\n    const rotation = optimalRotation(getState);\r\n    const board = getBoard(rotation);\r\n    const cells = getAvailableCells({ cells: board.cells });\r\n    if (cells.length === 0) return;\r\n    const cell = cells[Math.floor(Math.random() * cells.length)];\r\n\r\n    return {\r\n        cellId: cell.id,\r\n        rotation\r\n    };\r\n}\r\n\r\nfunction optimalRotation(getState, cellId = null) {\r\n    let optimal = {\r\n        points: null,\r\n        rotation: null\r\n    };\r\n\r\n    for (const board of boards) {\r\n        const rotation = board.rotation;\r\n\r\n        if (!rotation) continue;\r\n\r\n        // State with current rotated cells\r\n        // and possibly the given cell\r\n        const state = Object.assign({}, getState(), {\r\n            cells: Object.assign(\r\n                {},\r\n                board.cells,\r\n                cellId == null\r\n                    ? null\r\n                    : {\r\n                          [cellId]: Object.assign({}, board.cells[cellId], {\r\n                              player: currentPlayer.id\r\n                          })\r\n                      }\r\n            )\r\n        });\r\n\r\n        const score = getBoardScoreByPlayer(state)[currentPlayer.id];\r\n        const points = score.points;\r\n        const playerWins = score.wins;\r\n\r\n        if (\r\n            optimal.points == null ||\r\n            points > optimal.points ||\r\n            (points === optimal.points && Math.random() > 0.5)\r\n        ) {\r\n            // We are about to replace our optimal rotation\r\n            // Make sure the opponent cannot win on the next turn\r\n            // with some move. This only applies to situations where we have are not winning ourselves, obviously\r\n            // if(!playerWins) {\r\n            //   const boards = getBoards(() => state);\r\n            //   const opponentWins = winningMove(() => state, { player: nextPlayer, boardsToConsider: boards });\r\n\r\n            //   if(opponentWins) {\r\n            //     // Cancel plans\r\n            //     continue;\r\n            //   }\r\n            // }\r\n\r\n            // All good\r\n            optimal = { points, rotation };\r\n        }\r\n    }\r\n\r\n    if (optimal.rotation) {\r\n        return optimal.rotation;\r\n    } else {\r\n        // If all rotations have been dropped because the opponent would win,\r\n        // we are officially screwed. We would lose anyway, just return a random rotation\r\n        const boardsWithRotation = boards.filter(\r\n            board => board.rotation != null\r\n        );\r\n        return boardsWithRotation[\r\n            Math.floor(Math.random() * boardsWithRotation.length)\r\n        ].rotation;\r\n    }\r\n}\r\n\r\nfunction computeMetadata(getState) {\r\n    return getMetadata(getState());\r\n}\r\n","import { computeAndDoMove } from \"./ai\";\r\nimport { getActivePlayerId } from \"../selectors/playerSelectors\";\r\n\r\nexport const SET_PLAYER_NAME = \"SET_PLAYER_NAME\";\r\nexport function setPlayerName(playerId, name) {\r\n    return {\r\n        type: SET_PLAYER_NAME,\r\n        playerId,\r\n        name\r\n    };\r\n}\r\n\r\nexport const SET_PLAYER_AI = \"SET_PLAYER_AI\";\r\nexport function setPlayerAI(playerId, isAI) {\r\n    return (dispatch, getState) => {\r\n        dispatch({\r\n            type: SET_PLAYER_AI,\r\n            playerId,\r\n            isAI\r\n        });\r\n\r\n        // If we just made a player an AI and\r\n        // it is the active player, execute a move!\r\n        if (isAI && getActivePlayerId(getState()) === playerId) {\r\n            dispatch(computeAndDoMove());\r\n        }\r\n    };\r\n}\r\n\r\nexport const TOGGLE_OPTIONS = \"TOGGLE_OPTIONS\";\r\nexport function toggleOptions() {\r\n    return {\r\n        type: TOGGLE_OPTIONS\r\n    };\r\n}\r\n\r\nexport const SET_AI_MOVE_DELAY = \"SET_AI_MOVE_DELAY\";\r\nexport function setAIMoveDelay(timeout) {\r\n    return {\r\n        type: SET_AI_MOVE_DELAY,\r\n        timeout\r\n    };\r\n}\r\n\r\nexport const SET_AUTOMATIC_RESTART = \"SET_AUTOMATIC_RESTART\";\r\nexport function setAutomaticRestart(enabled) {\r\n    return {\r\n        type: SET_AUTOMATIC_RESTART,\r\n        enabled\r\n    };\r\n}\r\n\r\nexport const SET_ANIMATIONS_ENABLED = \"SET_ANIMATIONS_ENABLED\";\r\nexport function setAnimationsEnabled(enabled) {\r\n    return {\r\n        type: SET_ANIMATIONS_ENABLED,\r\n        enabled\r\n    };\r\n}\r\n\r\nexport const SET_ANIMATION_DURATION = \"SET_ANIMATION_DURATION\";\r\nexport function setAnimationDuration(duration) {\r\n    return {\r\n        type: SET_ANIMATION_DURATION,\r\n        duration\r\n    };\r\n}\r\n\r\nexport const SET_SHOW_LOAD_SAVE_BUTTONS = \"SET_SHOW_LOAD_SAVE_BUTTONS\";\r\nexport function setShowLoadSaveButtons(show) {\r\n    return {\r\n        type: SET_SHOW_LOAD_SAVE_BUTTONS,\r\n        show\r\n    };\r\n}\r\n\r\nexport const SET_FIENE_MODE = \"SET_FIENE_MODE\";\r\nexport function setFieneMode(on) {\r\n    return {\r\n        type: SET_FIENE_MODE,\r\n        on: !!on\r\n    };\r\n}\r\n","import {\r\n    getAvailableCells,\r\n    getWinningCellsByPlayer,\r\n    getBoardScoreByPlayer,\r\n    getCell,\r\n    getQuadrantRowAndColumn\r\n} from \"../selectors/cellSelectors\";\r\nimport { getPlayers, getActivePlayer } from \"../selectors/playerSelectors\";\r\nimport { computeAndDoMove } from \"./ai\";\r\n\r\nexport const TRY_PICK_CELL = \"TRY_PICK_CELL\";\r\n// Returns: true/false if it's game over after picking the cell (due to win or draw)\r\nexport function tryPickCell(cellId, playerId) {\r\n    return (dispatch, getState) => {\r\n        const errorMessage = validateMove(getState, cellId, playerId);\r\n\r\n        if (errorMessage) {\r\n            return dispatch(showError(errorMessage));\r\n        }\r\n\r\n        // Cell\r\n        // The color is only shown in Fiene Mode\r\n        dispatch(pickCell(cellId, playerId, getState().ui.cellColor));\r\n\r\n        // Fiene Mode => we are not picking the quadrant to rotate anymore,\r\n        // instead we simply rotate the quadrant of the cell in a random direction\r\n        if (getState().options.fieneMode) {\r\n            const { row, column } = getQuadrantRowAndColumn(getState(), cellId);\r\n            dispatch(animateQuadrant(row, column, cellId % 2 === 0));\r\n        }\r\n\r\n        // Score\r\n        const scores = getBoardScoreByPlayer(getState());\r\n        dispatch(updateScores(scores));\r\n\r\n        return checkWinner(dispatch, getState);\r\n    };\r\n}\r\n\r\nexport const PICK_CELL = \"PICK_CELL\";\r\nexport function pickCell(cellId, playerId, color) {\r\n    return {\r\n        type: PICK_CELL,\r\n        cellId,\r\n        playerId,\r\n        color\r\n    };\r\n}\r\n\r\nfunction checkWinner(dispatch, getState) {\r\n    const state = getState();\r\n    let isDraw = false;\r\n\r\n    // In Fiene Mode, no one can ever win\r\n    if (!state.options.fieneMode) {\r\n        const players = getPlayers(state);\r\n\r\n        const winningCellsByPlayer = getWinningCellsByPlayer(state);\r\n\r\n        const winners = []; // Will hold objects of { player: <player>, winningCells: <winningCells> }\r\n        for (let player of players) {\r\n            const winningCells = winningCellsByPlayer[player.id];\r\n\r\n            if (winningCells) {\r\n                winners.push({\r\n                    player,\r\n                    winningCells\r\n                });\r\n            }\r\n        }\r\n\r\n        // Do we have winning cells?\r\n        if (winners.length > 0) {\r\n            const winningCells = winners.reduce(\r\n                (cells, winner) => cells.concat(winner.winningCells),\r\n                []\r\n            );\r\n            dispatch(setWinningCells(winningCells));\r\n        }\r\n\r\n        // Do we have a single winner?\r\n        if (winners.length === 1) {\r\n            const { player } = winners[0];\r\n\r\n            dispatch(playerWon(player.id));\r\n\r\n            // Reset, if specified\r\n            if (state.options.automaticRestart) {\r\n                setTimeout(() => dispatch(restartGame()), 500);\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        // If both players won it's a draw\r\n        isDraw = winners.length === players.length;\r\n    }\r\n\r\n    // Also a draw => full board\r\n    // We only check this when necessary\r\n    if (!isDraw) {\r\n        const availableCells = getAvailableCells(state);\r\n        isDraw = availableCells.length === 0;\r\n    }\r\n\r\n    if (isDraw) {\r\n        dispatch(draw());\r\n\r\n        // Reset, if specified\r\n        if (state.options.automaticRestart) {\r\n            setTimeout(() => dispatch(restartGame()), 500);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Otherwise, no winner or draw\r\n    return false;\r\n}\r\n\r\nexport const DRAW = \"DRAW\";\r\nexport function draw() {\r\n    return {\r\n        type: DRAW\r\n    };\r\n}\r\n\r\nexport const PLAYER_WON = \"PLAYER_WON\";\r\nexport function playerWon(player) {\r\n    return {\r\n        type: PLAYER_WON,\r\n        player\r\n    };\r\n}\r\n\r\nexport const WINNING_CELLS = \"WINNING_CELLS\";\r\nexport function setWinningCells(cells) {\r\n    return {\r\n        type: WINNING_CELLS,\r\n        cells\r\n    };\r\n}\r\n\r\nexport const RESTART_GAME = \"RESTART_GAME\";\r\nexport function restartGame() {\r\n    return (dispatch, state) => {\r\n        dispatch({ type: RESTART_GAME });\r\n        dispatch(beginTurn());\r\n    };\r\n}\r\n\r\nexport const SELECT_QUADRANT = \"SELECT_QUADRANT\";\r\nexport function selectQuadrant(row, column) {\r\n    return {\r\n        type: SELECT_QUADRANT,\r\n        row,\r\n        column\r\n    };\r\n}\r\n\r\nexport const ANIMATE_QUADRANT = \"ANIMATE_QUADRANT\";\r\nexport function animateQuadrant(row, column, clockwise) {\r\n    return (dispatch, getState) => {\r\n        const state = getState();\r\n\r\n        // If animations are not enabled, fall back to immediate rotation\r\n        if (!state.options.animationsEnabled) {\r\n            dispatch(rotateQuadrant(row, column, clockwise));\r\n            return;\r\n        }\r\n\r\n        // Animation\r\n        dispatch({\r\n            type: ANIMATE_QUADRANT,\r\n            row,\r\n            column,\r\n            clockwise\r\n        });\r\n\r\n        // Actually rotate\r\n        const animationDuration = getState().options.animationDuration;\r\n        setTimeout(\r\n            () => dispatch(rotateQuadrant(row, column, clockwise)),\r\n            animationDuration\r\n        );\r\n    };\r\n}\r\n\r\nexport const ROTATE_QUADRANT = \"ROTATE_QUADRANT\";\r\n// Returns: true/false if it's game over after rotation\r\nexport function rotateQuadrant(row, column, clockwise) {\r\n    return (dispatch, getState) => {\r\n        dispatch(rotateQuadrantAction(row, column, clockwise));\r\n\r\n        // Scores\r\n        const scores = getBoardScoreByPlayer(getState());\r\n        dispatch(updateScores(scores));\r\n\r\n        const winningRotation = checkWinner(dispatch, getState);\r\n\r\n        if (!winningRotation) {\r\n            dispatch(beginTurn());\r\n        }\r\n\r\n        return winningRotation;\r\n    };\r\n}\r\n\r\nfunction rotateQuadrantAction(row, column, clockwise) {\r\n    return {\r\n        type: ROTATE_QUADRANT,\r\n        row,\r\n        column,\r\n        clockwise\r\n    };\r\n}\r\n\r\nfunction validateMove(getState, cellId, playerId) {\r\n    let errorMessage = null;\r\n\r\n    const state = getState();\r\n    const cell = getCell(getState(), cellId);\r\n\r\n    if (state.gameOver) {\r\n        errorMessage = `The game has ended`;\r\n    } else if (!cell) {\r\n        errorMessage = `Cell #${cell.id} does not exist!`;\r\n    } else if (cell.player != null) {\r\n        errorMessage = `Cell (${cell.row}, ${cell.col}) is not empty!`;\r\n    }\r\n\r\n    return errorMessage;\r\n}\r\n\r\nexport const SHOW_ERROR = \"SHOW_ERROR\";\r\nexport function showError(error) {\r\n    return {\r\n        type: SHOW_ERROR,\r\n        error\r\n    };\r\n}\r\n\r\nexport const HIDE_ERROR = \"HIDE_ERROR\";\r\nexport function hideError() {\r\n    return {\r\n        type: HIDE_ERROR\r\n    };\r\n}\r\n\r\nexport const BEGIN_TURN = \"BEGIN_TURN\";\r\nexport function beginTurn() {\r\n    return (dispatch, getState) => {\r\n        dispatch({ type: BEGIN_TURN });\r\n\r\n        const state = getState();\r\n        const player = getActivePlayer(state);\r\n\r\n        if (!player || !player.isAI) return;\r\n\r\n        // AI => compute its move and do it with a delay\r\n        const timeout = state.options.aiMoveDelay;\r\n        setTimeout(\r\n            () => dispatch(computeAndDoMove(dispatch, getState)),\r\n            timeout\r\n        );\r\n    };\r\n}\r\n\r\nexport const UPDATE_SCORES = \"UPDATE_SCORES\";\r\nexport function updateScores(scores) {\r\n    return {\r\n        type: UPDATE_SCORES,\r\n        scores\r\n    };\r\n}\r\n\r\nexport const SHOW_LAST_MOVE = \"SHOW_LAST_MOVE\";\r\nexport function showLastMove() {\r\n    return {\r\n        type: SHOW_LAST_MOVE\r\n    };\r\n}\r\n\r\nexport const HIDE_LAST_MOVE = \"HIDE_LAST_MOVE\";\r\nexport function hideLastMove() {\r\n    return {\r\n        type: HIDE_LAST_MOVE\r\n    };\r\n}\r\n","import { PICK_CELL, ROTATE_QUADRANT, RESTART_GAME } from \"../actions\";\r\nimport { byId } from \"../helpers\";\r\nimport { BOARD_SIZE } from \"../constants\";\r\nimport { makeGetRotatedQuadrant } from \"../selectors/cellSelectors\";\r\n\r\nlet cellId = 0;\r\n\r\nconst allCells = [];\r\nfor (let row = 0; row < BOARD_SIZE; row++) {\r\n    for (let col = 0; col < BOARD_SIZE; col++) {\r\n        allCells.push({\r\n            id: cellId++,\r\n            row: row,\r\n            col: col\r\n        });\r\n    }\r\n}\r\n\r\nexport const initialState = byId(allCells);\r\n\r\nfunction cells(state = initialState, action) {\r\n    switch (action.type) {\r\n        case PICK_CELL:\r\n            const { cellId, color } = action;\r\n            const cell = state[cellId];\r\n\r\n            if (cell.player != null) {\r\n                throw new Error(\r\n                    `Cell (${cell.row}, ${cell.col}) is not empty!`\r\n                );\r\n            }\r\n\r\n            return Object.assign({}, state, {\r\n                [cell.id]: Object.assign({}, cell, {\r\n                    player: action.playerId,\r\n                    color\r\n                })\r\n            });\r\n\r\n        case ROTATE_QUADRANT:\r\n            const { row, column, clockwise } = action;\r\n\r\n            // These are just the changed cells of the quadrant\r\n            const rotatedQuadrant = makeGetRotatedQuadrant(\r\n                row,\r\n                column,\r\n                clockwise\r\n            )({ cells: state });\r\n\r\n            return Object.assign({}, state, rotatedQuadrant);\r\n\r\n        case RESTART_GAME:\r\n            return byId(allCells);\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport default cells;\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { tryPickCell } from \"../actions\";\r\nimport { getActivePlayer } from \"../selectors/playerSelectors\";\r\n\r\nconst Cell = ({\r\n    cell,\r\n    tryPickCell,\r\n    activePlayerId,\r\n    lastMove,\r\n    isEnabled,\r\n    canRotateQuadrant,\r\n    isWinningCell,\r\n    isComputedByAi,\r\n    showLastMove,\r\n    animationsEnabled,\r\n    animationDuration,\r\n    fieneMode\r\n}) => {\r\n    return (\r\n        <span\r\n            style={getStyle()}\r\n            className={getClassNames()}\r\n            onClick={\r\n                isEnabled ? () => tryPickCell(cell.id, activePlayerId) : null\r\n            }\r\n        />\r\n    );\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"cell\"];\r\n\r\n        if (!fieneMode && cell.player) {\r\n            classNames.push(`player-${cell.player}`);\r\n        } else {\r\n            if (!cell.color) {\r\n                classNames.push(\"empty\");\r\n            }\r\n        }\r\n\r\n        if (showLastMove && lastMove.cellId === cell.id) {\r\n            classNames.push(\"last-move\");\r\n        }\r\n\r\n        if (isWinningCell) {\r\n            classNames.push(\"winning\");\r\n        }\r\n\r\n        if (isComputedByAi) {\r\n            classNames.push(\"ai-preview\");\r\n        }\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n\r\n    function getStyle() {\r\n        const style = {};\r\n\r\n        if (animationsEnabled) {\r\n            const animationDurationInSeconds = animationDuration / 1000;\r\n\r\n            Object.assign(style, {\r\n                transition: `background-color ${animationDurationInSeconds}s`\r\n            });\r\n        }\r\n\r\n        if (fieneMode && cell.color) {\r\n            Object.assign(style, {\r\n                backgroundColor: cell.color\r\n            });\r\n        }\r\n\r\n        return style;\r\n    }\r\n};\r\n\r\nexport default connect(\r\n    (state, props) => ({\r\n        activePlayerId: state.activePlayer,\r\n        lastMove: state.lastMove,\r\n        isEnabled:\r\n            !state.ui.showLastMove &&\r\n            !state.draw &&\r\n            state.canPickCell &&\r\n            props.cell.player == null &&\r\n            (getActivePlayer(state) && !getActivePlayer(state).isAI),\r\n        canRotateQuadrant: !state.draw && state.canRotateQuadrant,\r\n        isWinningCell: state.ui.winningCells.some(\r\n            cell => cell.id === props.cell.id\r\n        ),\r\n        isComputedByAi:\r\n            state.ui.computedMove &&\r\n            state.ui.computedMove.cellId === props.cell.id,\r\n        showLastMove: state.ui.showLastMove,\r\n        animationsEnabled: state.options.animationsEnabled,\r\n        animationDuration: state.options.animationDuration,\r\n        fieneMode: state.options.fieneMode\r\n    }),\r\n    { tryPickCell }\r\n)(Cell);\r\n","import React from \"react\";\r\nimport SVG from 'react-inlinesvg';\r\nimport clockwiseArrow from \"../svg/clockwise.svg\";\r\nimport counterClockwiseArrow from \"../svg/counter-clockwise.svg\";\r\n\r\nconst Arrow = ({\r\n    row,\r\n    column,\r\n    clockwise,\r\n    rotateQuadrant,\r\n    animateQuadrant,\r\n    aiRotation,\r\n    activePlayerId,\r\n    lastRotation,\r\n    showLastMove,\r\n    isSelected,\r\n    animationsEnabled,\r\n    className,\r\n    src,\r\n}) => {\r\n    return (\r\n        <span\r\n            className={getClassNames()}\r\n            onClick={rotate}\r\n        >\r\n            <SVG src={clockwise ? clockwiseArrow : counterClockwiseArrow}></SVG>\r\n        </span>\r\n    );\r\n\r\n    function rotate(e) {\r\n        e.stopPropagation();\r\n        // We are showing a previous move,\r\n        // you cannot click to rotate currently\r\n        if (showLastMove) return false;\r\n        // Our Quadrant must be selected, otherwise something fishy is going on\r\n        if (!isSelected) return false;\r\n\r\n        if (animationsEnabled) {\r\n            animateQuadrant(row, column, clockwise);\r\n        } else {\r\n            rotateQuadrant(row, column, clockwise);\r\n        }\r\n    }\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"arrow\", className];\r\n\r\n        classNames.push(clockwise ? \"clockwise\" : \"counter-clockwise\");\r\n\r\n        // Are we using this arrow to show a computed AI move?\r\n        if (isSameRotation(aiRotation)) {\r\n            classNames.push(\"ai-preview\");\r\n        }\r\n\r\n        if (showLastMove && isSameRotation(lastRotation)) {\r\n            classNames.push(\"last-rotation\");\r\n        }\r\n\r\n        classNames.push(`player-${activePlayerId}`);\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n\r\n    function isSameRotation(rotation) {\r\n        return (\r\n            rotation &&\r\n            rotation.row === row &&\r\n            rotation.column === column &&\r\n            rotation.clockwise === clockwise\r\n        );\r\n    }\r\n};\r\n\r\nexport default Arrow;\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport Cell from \"./Cell\";\r\nimport { rotateQuadrant, animateQuadrant, selectQuadrant } from \"../actions\";\r\nimport Arrow from \"./Arrow\";\r\n\r\nconst Quadrant = ({\r\n    quadrant,\r\n    canRotateQuadrant,\r\n    hasSelectedQuadrant,\r\n    isSelected,\r\n    row,\r\n    column,\r\n    rotateQuadrant,\r\n    selectQuadrant,\r\n    animateQuadrant,\r\n    aiRotation,\r\n    activePlayerId,\r\n    lastRotation,\r\n    showLastMove,\r\n    quadrantAnimation,\r\n    animationsEnabled,\r\n    animationDuration,\r\n}) => {\r\n    return (\r\n        <div className={getClassNames()} style={getStyle()} onClick={onClick}>\r\n            {quadrant.map((row, i) =>\r\n                row.map(cell => <Cell key={`cell-${cell.id}`} cell={cell} />)\r\n            )}\r\n\r\n            <div className=\"arrows\">\r\n                <Arrow {...getArrowParams(true)} />\r\n                <Arrow {...getArrowParams(false)} />\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n    function getStyle() {\r\n        if (!animationsEnabled || !isThisQuadrant(quadrantAnimation))\r\n            return null;\r\n\r\n        const animationDurationInSeconds = animationDuration / 1000;\r\n\r\n        return {\r\n            transform: `rotate(${quadrantAnimation.clockwise ? 90 : -90}deg)`,\r\n            transition: `all ${animationDurationInSeconds}s linear`\r\n        };\r\n    }\r\n\r\n    function onClick(e) {\r\n        if (!canRotateQuadrant) return null;\r\n\r\n        e.stopPropagation();\r\n\r\n        selectQuadrant(row, column);\r\n    }\r\n\r\n    function getArrowParams(clockwise) {\r\n        return {\r\n            row,\r\n            column,\r\n            clockwise,\r\n            rotateQuadrant,\r\n            animateQuadrant,\r\n            aiRotation,\r\n            activePlayerId,\r\n            lastRotation,\r\n            showLastMove,\r\n            isSelected,\r\n            animationsEnabled,\r\n            activePlayerId,\r\n        };\r\n    }\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"quadrant\"];\r\n\r\n        if (isSelected) {\r\n            classNames.push(\"selected\");\r\n        }\r\n\r\n        if (\r\n            showLastMove &&\r\n            lastRotation != null &&\r\n            lastRotation.row === row &&\r\n            lastRotation.column === column\r\n        ) {\r\n            classNames.push(\"show-last-move\");\r\n        }\r\n\r\n        if (\r\n            aiRotation &&\r\n            aiRotation.row === row &&\r\n            aiRotation.column === column\r\n        ) {\r\n            classNames.push(\"ai-preview\");\r\n        }\r\n\r\n        if (isThisQuadrant(quadrantAnimation) && animationsEnabled) {\r\n            classNames.push(\"animating\");\r\n        }\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n\r\n    function isThisQuadrant(quadrantObject) {\r\n        return (\r\n            quadrantObject &&\r\n            quadrantObject.row === row &&\r\n            quadrantObject.column === column\r\n        );\r\n    }\r\n};\r\n\r\nexport default connect(\r\n    (state, props) => ({\r\n        canRotateQuadrant: !state.gameOver && state.canRotateQuadrant,\r\n        hasSelectedQuadrant: state.ui.selectedQuadrant.row != null,\r\n        isSelected:\r\n            state.ui.selectedQuadrant.row === props.row &&\r\n            state.ui.selectedQuadrant.column === props.column,\r\n        aiRotation: state.ui.computedMove && state.ui.computedMove.rotation,\r\n        activePlayerId: state.activePlayer,\r\n        lastRotation: state.lastMove.rotation,\r\n        showLastMove: state.ui.showLastMove,\r\n        quadrantAnimation: state.ui.quadrantAnimation,\r\n        animationsEnabled: state.options.animationsEnabled,\r\n        animationDuration: state.options.animationDuration\r\n    }),\r\n    { rotateQuadrant, animateQuadrant, selectQuadrant }\r\n)(Quadrant);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport Quadrant from \"./Quadrant\";\r\nimport { getQuadrants2D } from \"../selectors/cellSelectors\";\r\nimport { getActivePlayer } from \"../selectors/playerSelectors\";\r\n\r\nconst Board = ({ quadrants, disableCells, enableQuadrants, showLastMove }) => {\r\n    return (\r\n        <div className={getClassNames()}>\r\n            {quadrants.map((quadrantRow, i) =>\r\n                quadrantRow.map((quadrant, j) =>\r\n                    <Quadrant\r\n                        key={`quadrant-${i}-${j}`}\r\n                        row={i}\r\n                        column={j}\r\n                        quadrant={quadrant}\r\n                    />\r\n                )\r\n            )}\r\n        </div>\r\n    );\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"board\"];\r\n\r\n        if (disableCells) {\r\n            classNames.push(\"disable-cells\");\r\n        }\r\n\r\n        if (enableQuadrants) {\r\n            classNames.push(\"enable-quadrants\");\r\n        }\r\n\r\n        if (showLastMove) {\r\n            classNames.push(\"show-last-move\");\r\n            classNames.push(\"disable-cells\");\r\n        }\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n};\r\n\r\nexport default connect(state => ({\r\n    quadrants: getQuadrants2D(state),\r\n    disableCells:\r\n        state.gameOver ||\r\n        state.ui.isAnimating ||\r\n        !state.canPickCell ||\r\n        getActivePlayer(state).isAI,\r\n    enableQuadrants: !state.gameOver && state.canRotateQuadrant,\r\n    showLastMove: state.ui.showLastMove\r\n}))(Board);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { computeMove, hideComputedMove, computeAndDoMove } from \"../actions/ai\";\r\nimport {\r\n    showLastMove,\r\n    hideLastMove,\r\n    restartGame,\r\n    toggleOptions,\r\n    saveToStorage,\r\n    loadFromStorage,\r\n    clearStorage\r\n} from \"../actions\";\r\nimport { activePlayerIsAI } from \"../selectors/playerSelectors\";\r\n\r\nconst Controls = ({\r\n    gameOver,\r\n    hasPreviousMove,\r\n    showingLastMove,\r\n    showingOptions,\r\n    hasComputedMove,\r\n    showAIButtons,\r\n    hasStoredState,\r\n    disableAIButtons,\r\n    computeMove,\r\n    hideComputedMove,\r\n    computeAndDoMove,\r\n    showLastMove,\r\n    hideLastMove,\r\n    restartGame,\r\n    toggleOptions,\r\n    saveToStorage,\r\n    clearStorage,\r\n    loadFromStorage,\r\n    showLoadSaveButtons,\r\n    fieneMode\r\n}) => {\r\n    if (fieneMode && !gameOver) return null;\r\n\r\n    return (\r\n        <div className=\"controls\">\r\n            <div className=\"buttons\">\r\n                {!fieneMode &&\r\n                    hasPreviousMove &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={toggleLastMove}\r\n                    >\r\n                        {showingLastMove ? `Hide last move` : `Show last move`}\r\n                    </button>}\r\n\r\n                {!fieneMode &&\r\n                    gameOver &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={() => restartGame()}\r\n                    >\r\n                        Restart game\r\n                    </button>}\r\n\r\n                {fieneMode &&\r\n                    gameOver &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={() => restartGame()}\r\n                    >\r\n                        Nog een keer!\r\n                    </button>}\r\n\r\n                {!fieneMode &&\r\n                    showAIButtons &&\r\n                    (hasComputedMove\r\n                        ? <button\r\n                              className=\"btn\"\r\n                              type=\"button\"\r\n                              onClick={hideComputedMove}\r\n                          >\r\n                              Hide AI move\r\n                          </button>\r\n                        : <button\r\n                              className=\"btn\"\r\n                              type=\"button\"\r\n                              disabled={disableAIButtons}\r\n                              onClick={computeMove}\r\n                          >\r\n                              Compute AI move\r\n                          </button>)}\r\n\r\n                {!fieneMode &&\r\n                    showAIButtons &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        disabled={disableAIButtons}\r\n                        onClick={computeAndDoMove}\r\n                    >\r\n                        Execute AI move\r\n                    </button>}\r\n\r\n                {!fieneMode &&\r\n                    !showingOptions &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={toggleOptions}\r\n                    >\r\n                        Options\r\n                    </button>}\r\n\r\n                {!fieneMode &&\r\n                    showLoadSaveButtons &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={saveToStorage}\r\n                    >\r\n                        Save state\r\n                    </button>}\r\n                {!fieneMode &&\r\n                    showLoadSaveButtons &&\r\n                    hasStoredState &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={loadFromStorage}\r\n                    >\r\n                        Load state\r\n                    </button>}\r\n                {!fieneMode &&\r\n                    showLoadSaveButtons &&\r\n                    hasStoredState &&\r\n                    <button\r\n                        className=\"btn\"\r\n                        type=\"button\"\r\n                        onClick={clearStorage}\r\n                    >\r\n                        Clear state\r\n                    </button>}\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n    function toggleLastMove() {\r\n        if (showingLastMove) {\r\n            hideLastMove();\r\n        } else {\r\n            showLastMove();\r\n        }\r\n    }\r\n};\r\nexport default connect(\r\n    state => ({\r\n        gameOver: state.gameOver,\r\n        hasPreviousMove: state.lastMove.cellId != null,\r\n        showingLastMove: state.ui.showLastMove,\r\n        showingOptions: state.ui.showOptions,\r\n        hasComputedMove: state.ui.computedMove != null,\r\n        showAIButtons: !state.gameOver,\r\n        disableAIButtons:\r\n            !state.gameStarted ||\r\n            state.gameOver ||\r\n            activePlayerIsAI(state) ||\r\n            state.ui.isAnimating,\r\n        hasStoredState: state.hasStoredState,\r\n        showLoadSaveButtons: state.options.showLoadSaveButtons,\r\n        fieneMode: state.options.fieneMode\r\n    }),\r\n    {\r\n        computeMove,\r\n        hideComputedMove,\r\n        computeAndDoMove,\r\n        showLastMove,\r\n        hideLastMove,\r\n        restartGame,\r\n        toggleOptions,\r\n        saveToStorage,\r\n        loadFromStorage,\r\n        clearStorage\r\n    }\r\n)(Controls);\r\n","export const SAVE_TO_STORAGE = \"SAVE_TO_STORAGE\";\r\nexport function saveToStorage() {\r\n    return (dispatch, getState) => {\r\n        dispatch({ type: SAVE_TO_STORAGE });\r\n        window.localStorage.state = JSON.stringify(getState());\r\n    };\r\n}\r\n\r\nexport const LOAD_FROM_STORAGE = \"LOAD_FROM_STORAGE\";\r\nexport function loadFromStorage() {\r\n    return {\r\n        type: LOAD_FROM_STORAGE\r\n    };\r\n}\r\n\r\nexport const CLEAR_STORAGE = \"CLEAR_STORAGE\";\r\nexport function clearStorage() {\r\n    return (dispatch, getState) => {\r\n        dispatch({ type: CLEAR_STORAGE });\r\n        window.localStorage.removeItem(\"state\");\r\n    };\r\n}\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\n\r\nconst ErrorMessage = ({ error }) => {\r\n    if (!error) return null;\r\n\r\n    return (\r\n        <div className=\"error\">\r\n            {error}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default connect(state => ({ error: state.error }))(ErrorMessage);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { getActivePlayer, getPlayer } from \"../selectors/playerSelectors\";\r\nimport fiene from \"../img/fiene.png\";\r\n\r\nconst StatusMessage = ({\r\n    gameStarted,\r\n    gameOver,\r\n    activePlayer,\r\n    winner,\r\n    fieneMode\r\n}) => {\r\n    // If the game has not started yet, display the game title\r\n    if (!gameStarted) {\r\n        return <h1>Pentago</h1>;\r\n    }\r\n\r\n    if (fieneMode) {\r\n        if (!gameOver) {\r\n            return <img className=\"fiene\" src={fiene} alt=\"Fiene\" />;\r\n        } else {\r\n            return <h2>Afgelopen!</h2>;\r\n        }\r\n    } else {\r\n        // Game has not ended, but no active player (yet)\r\n        if (!gameOver && activePlayer == null) return null;\r\n\r\n        if (!gameOver) {\r\n            return <h2>{`Player: ${activePlayer.name}`}</h2>;\r\n        } else {\r\n            if (winner) {\r\n                return <h2>{`${winner.name} wins!`}</h2>;\r\n            } else {\r\n                return <h2>It's a draw</h2>;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nexport default connect(state => ({\r\n    gameStarted: state.gameStarted,\r\n    gameOver: state.gameOver,\r\n    activePlayer: getActivePlayer(state),\r\n    winner: getPlayer(state.winner)(state),\r\n    fieneMode: state.options.fieneMode\r\n}))(StatusMessage);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { getPlayers } from \"../selectors/playerSelectors\";\r\nimport {\r\n    setPlayerName,\r\n    setPlayerAI,\r\n    toggleOptions,\r\n    setAIMoveDelay,\r\n    setAutomaticRestart,\r\n    beginTurn,\r\n    setAnimationsEnabled,\r\n    setAnimationDuration,\r\n    setShowLoadSaveButtons,\r\n    setFieneMode\r\n} from \"../actions\";\r\n\r\nconst Options = ({\r\n    gameStarted,\r\n    players,\r\n    isVisible,\r\n    aiMoveDelay,\r\n    automaticRestart,\r\n    animationsEnabled,\r\n    animationDuration,\r\n    fieneMode,\r\n    setPlayerName,\r\n    setPlayerAI,\r\n    toggleOptions,\r\n    setAIMoveDelay,\r\n    setAutomaticRestart,\r\n    setAnimationsEnabled,\r\n    setAnimationDuration,\r\n    beginTurn,\r\n    setShowLoadSaveButtons,\r\n    showLoadSaveButtons,\r\n    setFieneMode\r\n}) => {\r\n    const player1 = players.find(player => player.id === 1);\r\n    const player2 = players.find(player => player.id === 2);\r\n\r\n    return (\r\n        <div className={getClassNames()}>\r\n            <h2>Options</h2>\r\n\r\n            <div className=\"option-columns\">\r\n                <div className=\"option-column\">\r\n                    <label htmlFor=\"player-1-name\">Player 1 name</label>\r\n                    <label htmlFor=\"player-1-ai\">Controlled by AI</label>\r\n\r\n                    <label htmlFor=\"player-2-name\">Player 2 name</label>\r\n                    <label htmlFor=\"player-2-ai\">Controlled by AI</label>\r\n\r\n                    <label htmlFor=\"aiMoveDelay\">AI move delay (ms)</label>\r\n\r\n                    <label htmlFor=\"animationsEnabled\">\r\n                        Animations enabled\r\n                    </label>\r\n                    <label htmlFor=\"animationDuration\">\r\n                        Animation duration (ms)\r\n                    </label>\r\n\r\n                    <label htmlFor=\"automaticRestart\">Autorestart game</label>\r\n                    <label htmlFor=\"fieneMode\">Fiene Mode</label>\r\n\r\n                    <label htmlFor=\"showLoadSaveButtons\">\r\n                        Show load and save buttons\r\n                    </label>\r\n                </div>\r\n                <div className=\"option-column\">\r\n                    <input\r\n                        type=\"text\"\r\n                        value={player1.name}\r\n                        id=\"player-1-name\"\r\n                        onChange={e =>\r\n                            setPlayerName(player1.id, e.target.value)}\r\n                    />\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"player-1-ai\"\r\n                        checked={player1.isAI}\r\n                        onChange={e =>\r\n                            setPlayerAI(player1.id, e.target.checked)}\r\n                    />\r\n\r\n                    <input\r\n                        type=\"text\"\r\n                        value={player2.name}\r\n                        id=\"player-2-name\"\r\n                        onChange={e =>\r\n                            setPlayerName(player2.id, e.target.value)}\r\n                    />\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"player-2-ai\"\r\n                        checked={player2.isAI}\r\n                        onChange={e =>\r\n                            setPlayerAI(player2.id, e.target.checked)}\r\n                    />\r\n\r\n                    <input\r\n                        type=\"text\"\r\n                        id=\"aiMoveDelay\"\r\n                        defaultValue={aiMoveDelay}\r\n                        onBlur={e =>\r\n                            setAIMoveDelay(parseInt(e.target.value, 10))}\r\n                    />\r\n\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"animationsEnabled\"\r\n                        checked={animationsEnabled}\r\n                        onChange={e => setAnimationsEnabled(e.target.checked)}\r\n                    />\r\n                    <input\r\n                        type=\"text\"\r\n                        id=\"animationDuration\"\r\n                        defaultValue={animationDuration}\r\n                        onBlur={e =>\r\n                            setAnimationDuration(parseInt(e.target.value, 10))}\r\n                    />\r\n\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"automaticRestart\"\r\n                        checked={automaticRestart}\r\n                        onChange={e => setAutomaticRestart(e.target.checked)}\r\n                    />\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"fieneMode\"\r\n                        checked={fieneMode}\r\n                        onChange={e => setFieneMode(e.target.checked)}\r\n                    />\r\n\r\n                    <input\r\n                        type=\"checkbox\"\r\n                        id=\"showLoadSaveButtons\"\r\n                        checked={showLoadSaveButtons}\r\n                        onChange={e => setShowLoadSaveButtons(e.target.checked)}\r\n                    />\r\n                </div>\r\n            </div>\r\n\r\n            {isVisible && gameStarted\r\n                ? <button type=\"button\" className=\"btn\" onClick={toggleOptions}>\r\n                      Close\r\n                  </button>\r\n                : <button type=\"button\" className=\"btn\" onClick={startGame}>\r\n                      Start game\r\n                  </button>}\r\n        </div>\r\n    );\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"options\"];\r\n\r\n        if (isVisible) {\r\n            classNames.push(\"visible\");\r\n        }\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n\r\n    function startGame() {\r\n        toggleOptions();\r\n        beginTurn();\r\n    }\r\n};\r\n\r\nexport default connect(\r\n    state => ({\r\n        gameStarted: state.gameStarted,\r\n        players: getPlayers(state),\r\n        isVisible: state.ui.showOptions,\r\n        aiMoveDelay: state.options.aiMoveDelay,\r\n        automaticRestart: state.options.automaticRestart,\r\n        animationsEnabled: state.options.animationsEnabled,\r\n        animationDuration: state.options.animationDuration,\r\n        showLoadSaveButtons: state.options.showLoadSaveButtons,\r\n        fieneMode: state.options.fieneMode\r\n    }),\r\n    {\r\n        setPlayerName,\r\n        setPlayerAI,\r\n        toggleOptions,\r\n        setAIMoveDelay,\r\n        setAutomaticRestart,\r\n        setAnimationsEnabled,\r\n        setAnimationDuration,\r\n        beginTurn,\r\n        setShowLoadSaveButtons,\r\n        setFieneMode\r\n    }\r\n)(Options);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport { getPlayers } from \"../selectors/playerSelectors\";\r\n\r\nconst Score = ({ score, players, fieneMode }) => {\r\n    if (fieneMode) return null;\r\n\r\n    return (\r\n        <div className=\"score\">\r\n            <h2>Score</h2>\r\n            <h3>\r\n                {players[0].name} {score[players[0].id] || 0} -{\" \"}\r\n                {score[players[1].id] || 0} {players[1].name}\r\n            </h3>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default connect(state => ({\r\n    players: getPlayers(state),\r\n    score: state.ui.score,\r\n    fieneMode: state.options.fieneMode\r\n}))(Score);\r\n","import React from \"react\";\r\nimport { connect } from \"react-redux\";\r\nimport Board from \"./Board\";\r\nimport Controls from \"./Controls\";\r\nimport ErrorMessage from \"./ErrorMessage\";\r\nimport StatusMessage from \"./StatusMessage\";\r\nimport Options from \"./Options\";\r\nimport Score from \"./Score\";\r\n\r\nconst Game = ({ activePlayerId, gameOver, score, boardScores, fieneMode }) => {\r\n    return (\r\n        <div className={getClassNames()}>\r\n            <div className=\"column-center\">\r\n                <StatusMessage />\r\n                <Board />\r\n                <Score />\r\n\r\n                {\r\n                    // <pre style={ { textAlign: 'left', fontSize: '12pt', position: 'absolute', left: '15%' }  }>\r\n                    //   { JSON.stringify(boardScores, null, 4) }\r\n                    // </pre>\r\n                }\r\n\r\n                <Controls />\r\n                <ErrorMessage />\r\n                <Options />\r\n            </div>\r\n        </div>\r\n    );\r\n\r\n    function getClassNames() {\r\n        const classNames = [\"game\"];\r\n\r\n        if (gameOver) {\r\n            classNames.push(\"game-over\");\r\n        }\r\n\r\n        if (!fieneMode && activePlayerId) {\r\n            classNames.push(`player-${activePlayerId}`);\r\n        }\r\n\r\n        return classNames.join(\" \");\r\n    }\r\n};\r\n\r\nexport default connect(state => ({\r\n    activePlayerId: state.activePlayer,\r\n    gameOver: state.gameOver,\r\n    score: state.ui.score,\r\n    boardScores: state.scores,\r\n    fieneMode: state.options.fieneMode\r\n}))(Game);\r\n","import React from \"react\";\r\nimport { createDevTools } from \"redux-devtools\";\r\nimport LogMonitor from \"redux-devtools-log-monitor\";\r\nimport DockMonitor from \"redux-devtools-dock-monitor\";\r\n\r\nexport default createDevTools(\r\n    <DockMonitor toggleVisibilityKey=\"ctrl-h\" changePositionKey=\"ctrl-j\">\r\n        <LogMonitor />\r\n    </DockMonitor>\r\n);\r\n","import React from \"react\";\nimport Game from \"./Game\";\nimport DevTools from \"./DevTools\";\n\nconst Pentago = () =>\n    <div>\n        <Game />\n        {\n            // <DevTools />\n        }\n    </div>;\n\nexport default Pentago;\n","import { byId } from \"../helpers\";\r\nimport { SET_PLAYER_NAME, SET_PLAYER_AI, SET_FIENE_MODE } from \"../actions\";\r\n\r\nconst allPlayers = [\r\n    { id: 1, name: \"Red\", isAI: true },\r\n    { id: 2, name: \"Blue\", isAI: false }\r\n];\r\n\r\nexport const initialState = byId(allPlayers);\r\n\r\nexport default (state = initialState, action) => {\r\n    switch (action.type) {\r\n        case SET_PLAYER_NAME: {\r\n            const { playerId, name } = action;\r\n\r\n            return Object.assign({}, state, {\r\n                [playerId]: Object.assign({}, state[playerId], {\r\n                    name: name\r\n                })\r\n            });\r\n        }\r\n\r\n        case SET_PLAYER_AI: {\r\n            const { playerId, isAI } = action;\r\n\r\n            return Object.assign({}, state, {\r\n                [playerId]: Object.assign({}, state[playerId], {\r\n                    isAI: isAI\r\n                })\r\n            });\r\n        }\r\n\r\n        // In Fiene Mode, there is no AI\r\n        case SET_FIENE_MODE:\r\n            const { on } = action;\r\n            if (on) {\r\n                const newState = Object.assign({}, state);\r\n\r\n                for (let key of Object.keys(newState)) {\r\n                    newState[key] = Object.assign(newState[key], {\r\n                        isAI: false\r\n                    });\r\n                }\r\n\r\n                return newState;\r\n            }\r\n            break;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n};\r\n","import { combineReducers } from \"redux\";\r\nimport {\r\n    SELECT_QUADRANT,\r\n    PICK_CELL,\r\n    ROTATE_QUADRANT,\r\n    ANIMATE_QUADRANT,\r\n    PLAYER_WON,\r\n    BEGIN_TURN,\r\n    SHOW_LAST_MOVE,\r\n    HIDE_LAST_MOVE,\r\n    RESTART_GAME,\r\n    TOGGLE_OPTIONS,\r\n    WINNING_CELLS\r\n} from \"../actions\";\r\nimport { COMPUTED_MOVE, HIDE_COMPUTED_MOVE } from \"../actions/ai\";\r\nimport { COLORS } from \"../constants\";\r\n\r\nfunction selectedQuadrant(state = {}, action) {\r\n    switch (action.type) {\r\n        case SELECT_QUADRANT:\r\n            const { row, column } = action;\r\n            return Object.assign({}, { row, column });\r\n\r\n        case ROTATE_QUADRANT:\r\n        case RESTART_GAME:\r\n            return {};\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction winningCells(state = [], action) {\r\n    switch (action.type) {\r\n        case WINNING_CELLS:\r\n            return action.cells;\r\n\r\n        case RESTART_GAME:\r\n            return [];\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction score(state = {}, action) {\r\n    switch (action.type) {\r\n        case PLAYER_WON:\r\n            return Object.assign({}, state, {\r\n                [action.player]: (state[action.player] || 0) + 1\r\n            });\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction computedMove(state = null, action) {\r\n    switch (action.type) {\r\n        case COMPUTED_MOVE:\r\n            return action.move;\r\n\r\n        case HIDE_COMPUTED_MOVE:\r\n            return null;\r\n\r\n        case PICK_CELL:\r\n        case ROTATE_QUADRANT:\r\n        case BEGIN_TURN:\r\n            return null;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction showLastMove(state = false, action) {\r\n    switch (action.type) {\r\n        case SHOW_LAST_MOVE:\r\n            return true;\r\n\r\n        case HIDE_LAST_MOVE:\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction showOptions(state = true, action) {\r\n    switch (action.type) {\r\n        case TOGGLE_OPTIONS:\r\n            return !state;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction quadrantAnimation(state = null, action) {\r\n    switch (action.type) {\r\n        case ANIMATE_QUADRANT:\r\n            const { row, column, clockwise } = action;\r\n            return { row, column, clockwise };\r\n\r\n        case ROTATE_QUADRANT:\r\n        case RESTART_GAME:\r\n            return null;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction isAnimating(state = false, action) {\r\n    switch (action.type) {\r\n        case ANIMATE_QUADRANT:\r\n            return true;\r\n\r\n        case ROTATE_QUADRANT:\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction cellColor(state = null, action) {\r\n    switch (action.type) {\r\n        case BEGIN_TURN:\r\n        case ROTATE_QUADRANT:\r\n            // Pick a new color\r\n            return COLORS[Math.floor(Math.random() * COLORS.length)];\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst uiReducer = combineReducers({\r\n    selectedQuadrant,\r\n    winningCells,\r\n    score,\r\n    computedMove,\r\n    showLastMove,\r\n    showOptions,\r\n    quadrantAnimation,\r\n    isAnimating,\r\n    cellColor\r\n});\r\n\r\nexport default uiReducer;\r\n","import { combineReducers } from \"redux\";\r\nimport {\r\n    SET_AI_MOVE_DELAY,\r\n    SET_AUTOMATIC_RESTART,\r\n    SET_ANIMATIONS_ENABLED,\r\n    SET_ANIMATION_DURATION,\r\n    SET_SHOW_LOAD_SAVE_BUTTONS,\r\n    SET_FIENE_MODE\r\n} from \"../actions\";\r\n\r\nfunction aiMoveDelay(state = 500, action) {\r\n    switch (action.type) {\r\n        case SET_AI_MOVE_DELAY:\r\n            const { timeout } = action;\r\n\r\n            if (isNaN(timeout) || typeof timeout !== \"number\") {\r\n                return state;\r\n            }\r\n\r\n            return timeout;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction automaticRestart(state = false, action) {\r\n    switch (action.type) {\r\n        case SET_AUTOMATIC_RESTART:\r\n            const { enabled } = action;\r\n            return enabled;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction animationsEnabled(state = true, action) {\r\n    switch (action.type) {\r\n        case SET_ANIMATIONS_ENABLED:\r\n            const { enabled } = action;\r\n            return enabled;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction animationDuration(state = 500, action) {\r\n    switch (action.type) {\r\n        case SET_ANIMATION_DURATION:\r\n            const { duration } = action;\r\n\r\n            if (isNaN(duration) || typeof duration !== \"number\") {\r\n                return state;\r\n            }\r\n\r\n            return duration;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction showLoadSaveButtons(state = false, action) {\r\n    switch (action.type) {\r\n        case SET_SHOW_LOAD_SAVE_BUTTONS:\r\n            const { show } = action;\r\n            return show;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction fieneMode(state = false, action) {\r\n    switch (action.type) {\r\n        case SET_FIENE_MODE:\r\n            const { on } = action;\r\n            return on;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nconst optionsReducer = combineReducers({\r\n    aiMoveDelay,\r\n    automaticRestart,\r\n    animationsEnabled,\r\n    animationDuration,\r\n    showLoadSaveButtons,\r\n    fieneMode\r\n});\r\n\r\nexport default optionsReducer;\r\n","import { combineReducers } from \"redux\";\r\nimport cellsReducer from \"./cellsReducer\";\r\nimport playersReducer from \"./playersReducer\";\r\nimport uiReducer from \"./uiReducer\";\r\nimport optionsReducer from \"./optionsReducer\";\r\nimport {\r\n    PICK_CELL,\r\n    ROTATE_QUADRANT,\r\n    ANIMATE_QUADRANT,\r\n    SHOW_ERROR,\r\n    HIDE_ERROR,\r\n    BEGIN_TURN,\r\n    PLAYER_WON,\r\n    DRAW,\r\n    RESTART_GAME,\r\n    UPDATE_SCORES,\r\n    LOAD_FROM_STORAGE,\r\n    SAVE_TO_STORAGE,\r\n    CLEAR_STORAGE\r\n} from \"../actions\";\r\n\r\nconst rootReducer = combineReducers({\r\n    cells: cellsReducer,\r\n    players: playersReducer,\r\n    ui: uiReducer,\r\n    options: optionsReducer,\r\n    gameStarted,\r\n    activePlayer,\r\n    lastMove,\r\n    winner,\r\n    gameOver,\r\n    error,\r\n    canPickCell,\r\n    canRotateQuadrant,\r\n    scores,\r\n    hasStoredState\r\n});\r\n\r\nexport default function(state = {}, action) {\r\n    state = localStorage(state, action);\r\n    return rootReducer(state, action);\r\n}\r\n\r\nfunction localStorage(state = {}, action) {\r\n    switch (action.type) {\r\n        case LOAD_FROM_STORAGE:\r\n            const stored = window.localStorage.state;\r\n            if (!stored) return state;\r\n\r\n            try {\r\n                return JSON.parse(stored);\r\n            } catch (e) {\r\n                return state;\r\n            }\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction activePlayer(state = 1, action) {\r\n    switch (action.type) {\r\n        case ROTATE_QUADRANT:\r\n            return state % 2 + 1;\r\n\r\n        case RESTART_GAME:\r\n            return 1;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction lastMove(state = {}, action) {\r\n    switch (action.type) {\r\n        case PICK_CELL:\r\n            // Erase rotation of previous player\r\n            return { cellId: action.cellId };\r\n\r\n        case ANIMATE_QUADRANT:\r\n        case ROTATE_QUADRANT:\r\n            const { row, column, clockwise } = action;\r\n\r\n            // Add rotation to current player\r\n            return Object.assign({}, state, {\r\n                rotation: { row, column, clockwise }\r\n            });\r\n\r\n        case RESTART_GAME:\r\n            return {};\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction winner(state = null, action) {\r\n    switch (action.type) {\r\n        case PLAYER_WON:\r\n            return action.player;\r\n\r\n        case RESTART_GAME:\r\n            return null;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction gameOver(state = false, action) {\r\n    switch (action.type) {\r\n        case PLAYER_WON:\r\n        case DRAW:\r\n            return true;\r\n\r\n        case RESTART_GAME:\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction error(state = null, action) {\r\n    switch (action.type) {\r\n        case SHOW_ERROR:\r\n            return action.error;\r\n\r\n        case HIDE_ERROR:\r\n        case PICK_CELL:\r\n            return null;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction canPickCell(state = false, action) {\r\n    switch (action.type) {\r\n        case BEGIN_TURN:\r\n            return true;\r\n\r\n        case PICK_CELL:\r\n        case RESTART_GAME:\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction canRotateQuadrant(state = false, action) {\r\n    switch (action.type) {\r\n        case ANIMATE_QUADRANT:\r\n        case ROTATE_QUADRANT:\r\n        case RESTART_GAME:\r\n            return false;\r\n\r\n        case PICK_CELL:\r\n            return true;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction scores(state = {}, action) {\r\n    switch (action.type) {\r\n        case UPDATE_SCORES:\r\n            return action.scores;\r\n\r\n        case RESTART_GAME:\r\n            return {};\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction gameStarted(state = false, action) {\r\n    switch (action.type) {\r\n        case BEGIN_TURN:\r\n            return true;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nfunction hasStoredState(state, action) {\r\n    if (typeof state === \"undefined\") {\r\n        return window.localStorage.state != null;\r\n    }\r\n\r\n    switch (action.type) {\r\n        case SAVE_TO_STORAGE:\r\n            return true;\r\n\r\n        case CLEAR_STORAGE:\r\n            return false;\r\n\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n","// In production, we register a service worker to serve assets from local cache.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on the \"N+1\" visit to a page, since previously\n// cached resources are updated in the background.\n\n// To learn more about the benefits of this model, read https://goo.gl/KwvDNy.\n// This link also includes instructions on opting out of this behavior.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport default function register() {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebookincubator/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (!isLocalhost) {\n        // Is not local host. Just register service worker\n        registerValidSW(swUrl);\n      } else {\n        // This is running on localhost. Lets check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the old content will have been purged and\n              // the fresh content will have been added to the cache.\n              // It's the perfect time to display a \"New content is\n              // available; please refresh.\" message in your web app.\n              console.log('New content is available; please refresh.');\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import \"./polyfills\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Pentago from \"./components/Pentago\";\nimport { Provider } from \"react-redux\";\nimport buildStore from \"./store/buildStore\";\nimport \"./css/index.css\";\nimport registerServiceWorker from \"./registerServiceWorker\";\n\nconst store = buildStore();\n\nReactDOM.render(\n    <Provider store={store}>\n        <Pentago />\n    </Provider>,\n    document.getElementById(\"root\")\n);\n\n// This only works on secure origins (i.e., not http://)\n// registerServiceWorker();\n","import { createStore, applyMiddleware, compose } from \"redux\";\r\nimport thunk from \"redux-thunk\";\r\nimport DevTools from \"../components/DevTools\";\r\nimport rootReducer from \"../reducers/rootReducer\";\r\n\r\nexport default initialState =>\r\n    createStore(\r\n        rootReducer,\r\n        initialState,\r\n        compose(applyMiddleware(thunk), DevTools.instrument())\r\n    );\r\n"],"sourceRoot":""}