<!doctype html>
<html >
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Move and Resize</title>
  <script src="angular.min.js"></script>
  <link rel="icon" type="image/png" href="favicon.png" />
</head>

<body ng-app="MoveAndResize">
<div class="shape one" move-and-resize>
    <span class="resize sw">➔</span>
    <span class="resize ne">➔</span>
    <span class="resize nw">➔</span>
    <span class="resize se">➔</span>
</div>

<div class="shape two" move-and-resize>
    <span class="resize sw">➔</span>
    <span class="resize ne">➔</span>
    <span class="resize nw">➔</span>
    <span class="resize se">➔</span>
</div>

<div class="shape three" move-and-resize>
    <span class="resize sw">➔</span>
    <span class="resize ne">➔</span>
    <span class="resize nw">➔</span>
    <span class="resize se">➔</span>
</div>

<style>

* {
    box-sizing: border-box;
}

body {
    padding: 0;
    background-color: #eeeeec;
    margin: 0;
}

.shape {
    position: fixed;
    width: 34vmin;
    height: 34vmin;
    box-shadow: 0 0 10px #2e3436;
    touch-action: none;
}

.shape:hover {
    cursor: move;
}

.shape.is-dragging, .shape.is-resizing {
    opacity: 0.5;
}

.shape > .resize {
    position: absolute;
    color: black;
}

.shape > .resize.ne {
    bottom: 100%;
    left: 100%;
    transform: rotate(-45deg);
}

.shape > .resize.sw {
    top: 100%;
    right: 100%;
    transform: rotate(135deg);
}

.shape > .resize.se {
    top: 100%;
    left: 100%;
    transform: rotate(45deg);
}

.shape > .resize.nw {
    bottom: 100%;
    right: 100%;
    transform: rotate(-135deg);
}

.shape.one > .resize.ne {
    bottom: 87.5%;
    left: 87.5%;
}

.shape.one > .resize.nw {
    bottom: 87.5%;
    right: 87.5%;
}

.shape.one > .resize.se {
    top: 87.5%;
    left: 87.5%;
}

.shape.one > .resize.sw {
    top: 87.5%;
    right: 87.5%;
}

.shape > .resize.ne:hover,  .shape > .resize.sw:hover {
    cursor: ne-resize;
}

.shape > .resize.nw:hover,  .shape > .resize.se:hover {
    cursor: nw-resize;
}

.one { background-color: #cc0000; top: 5%; left: 5%; border-radius: 50%;  }
.two { background-color: #73d216; top: calc(50% - 17vmin); left: calc(50% - 17vmin); }
.three { background-color: #3465a4; top: calc(95% - 34vmin); left: calc(95% - 34vmin); border-radius: 20% 0; }

</style>

<script>
(function() {
    var app = angular.module("MoveAndResize", []);

    app.factory("moveAndResizeService", [function() {
        ["mouseup", "touchend"].forEach(function(type) {
            document.addEventListener(type, onDragEnd);
        });

        ["mousemove", "touchmove"].forEach(function(type) {
            document.addEventListener(type, onMove);
        });

        // All draggable elements on the current page
        var elements = [];

        // The unit used for all dimensions
        // Should probably be made configurable,
        // and perhaps seperately for width / height
        var DIMENSIONS_UNIT = "vmin";

        // The class that identifies elements that allow resizing
        var RESIZE_CSS_CLASS = "resize";

        // The CSS class applied to the element currently being dragged.
        // Could be made configurable
        var RESIZING_CSS_CLASS = "is-resizing";

        // The CSS class applied to every registered element
        // Could be made configurable
        var DRAGGABLE_CSS_CLASS = "draggable";

        // The CSS class applied to the element currently being dragged.
        // Could be made configurable
        var DRAGGING_CSS_CLASS = "is-dragging";

        // Amount of pixels of a shape that should remain on screen,
        // preventing the shape from being entirely dragged off screen.
        // Could be made configurable
        var MIN_PIXELS_ON_SCREEN = 20;

        // Element currently being dragged
        var drag = {
            // Element being dragged now,
            // DOM Element reference
            element: null,
            // (x,y) is the offset from the top left
            // of the element where the dragging started
            // (i.e., the offset of the mouse within the element upon mousedown)
            // This offset is in percentages to support page resizes after moving.
            x: null,
            y: null
        };

        var DIRECTION = {
            TOPLEFT: 'top-left',
            TOPRIGHT: 'top-right',
            BOTTOMLEFT: 'bottom-left',
            BOTTOMRIGHT: 'bottom-right'
        };

        var resize = {
            // Element being resized now,
            // DOM Element reference
            element: null,
            // The (x,y) coordinates of the mouse when resizing started
            x: null,
            y: null,
            // The initial width/height of the element when resizing started.
            // We always record width in vw and height in vh, to support page resizes
            width: null,
            height: null,
            top: null,
            left: null,
            direction: null // See DIRECTION
        };

        var isDragging = false;
        var isResizing = false;

        /**
         * Registers a DOM element, enabling it to be dragged
         * @param {Element} element DOM element to register
         */
        function register(element) {
            elements.push(element);

            element.classList.add(DRAGGABLE_CSS_CLASS);

            ["mousedown", "touchstart"].forEach(function(type) {
                element.addEventListener(
                    type,
                    function(e) {
                        var tagName = e.target.tagName.toLowerCase();
                        if (
                            tagName === "input" ||
                            tagName === "select" ||
                            tagName === "textarea" ||
                            tagName === "button" ||
                            tagName === "label"
                        ) {
                            // When selecting any user input related element,
                            // do not allow dragging and do not prevent the default
                            // action.
                            return;
                        }

                        // In addition, make sure that dragging a scrollbar does not start the dragging either.
                        // We can check this by looking at the X coordinate of the mouse position with respect
                        // to the target element. A vertical scrollbar is not included in .clientWidth, which means
                        // we are dragging a scrollbar when the X coordinate of the mouse is higher than the left element
                        // offset + its clientWidth.

                        var bRect = e.target.getBoundingClientRect();
                        if (e.clientX > bRect.left + e.target.clientWidth) {
                            return;
                        }

                        if(e.ctrlKey || e.target.classList.contains(RESIZE_CSS_CLASS)) {
                            onResizeStart(e, element);
                        } else {
                            // Drag
                            onDragStart(e, element);
                        }
                    }, { passive: true }
                );

            });
        }

        /**
         * Deregisters a DOM element, disabling dragging functionality
         * @param {Element} element DOM element to deregister
         */
        function deregister(element) {
            var index = elements.indexOf(element);
            if (index > -1) {
                elements.splice(index, 1);
            }

            element.classList.remove(DRAGGABLE_CSS_CLASS);

            ["mousedown", "touchstart"].forEach(function(type) {
                element.removeEventListener(type);
            });
        }

        // Gives the given element the highest z-index of all
        // currently registered elements
        function moveToTop(element) {
            var sortedElements = elements.sort(function(a, b) {
                var zIndexA = getZIndex(a);
                var zIndexB = getZIndex(b);

                return zIndexA > zIndexB ? 1 : zIndexA === zIndexB ? 0 : -1;
            });

            // We take the lowest zIndex as starting point and assign new indices to all elements.
            // By definition of the mousedown triggering on a shape, we know sortedShapes will have at least one element,
            // null check is superfluous here.
            var zIndex = getZIndex(sortedElements[0]);

            sortedElements.forEach(function(se) {
                // The shape being dragged is assigned the last (= highest) zIndex
                // when this loop has finished, so skip it now.
                if (se === element) return;

                se.style.zIndex = zIndex++;
            });

            // The shape being dragged will end up with the highest zIndex here
            element.style.zIndex = zIndex;
        }

        // Changes a CSS name (e.g., "z-index") to the property name in the DOM element's style object (e.g., "zIndex")
        function cssNameToProperty(cssName) {
            return cssName.replace(/([a-z])-([a-z])/g, function(_, a, b) { return a + b.toUpperCase(); });
        }

        function getCssPropertyValue(element, cssProperty, callback) {
            if (element == null) return null;
            var styleProperty = cssNameToProperty(cssProperty);

            var property = element.style[styleProperty] || getComputedStyle(element).getPropertyValue(cssProperty);
            if(typeof callback === 'function') {
                return callback(property);
            }

            return property;
        }

        function getZIndex(element) {
            return getCssPropertyValue(element, "z-index", function(value) {
                return parseInt(value, 10) || 0;
            });
        }

        function onDragStart(e, element) {
            isDragging = true;

            moveToTop(element);

            var bRect = element.getBoundingClientRect();

            var xy = getClientXY(e);

            drag.x =
                xy.clientX / window.innerWidth - bRect.left / window.innerWidth;
            drag.y =
                xy.clientY / window.innerHeight -
                bRect.top / window.innerHeight;

            drag.element = element;

            element.classList.add(DRAGGING_CSS_CLASS);
        }

        // TODO => this is both a dragend / resizeend, so rename
        function onDragEnd() {
            if(isDragging) {
                if (drag.element != null) {
                    drag.element.classList.remove(DRAGGING_CSS_CLASS);
                    drag.element = null;
                }
                drag.x = null;
                drag.y = null;
                isDragging = false;
            } else {
                if (resize.element != null) {
                    resize.element.classList.remove(RESIZING_CSS_CLASS);
                    resize.element = null;
                }

                resize.x = null;
                resize.y = null;
                resize.width = null;
                resize.height = null;
                isResizing = null;
            }
        }

        function onResizeStart(e, element) {
            isResizing = true;

            element.classList.add(RESIZING_CSS_CLASS);

            var bRect = element.getBoundingClientRect();

            var xy = getClientXY(e);

            resize.x = xy.clientX;
            resize.y = xy.clientY;
            resize.element = element;

            // We record starting width / height in vw / vh respectively.
            // This is much better than pixels as it automatically supports resizing the viewport.
            // It's the same as using % for top / left for positioning.
            // getBoundingClientRect() always returns pixels
            resize.width = (bRect.width / window.innerWidth) * 100;
            resize.height = (bRect.height / window.innerHeight) * 100;
            resize.top = (bRect.top / window.innerHeight) * 100;
            resize.left = (bRect.left / window.innerWidth) * 100;

            // Calculate resize direction
            var centerX = bRect.left + (bRect.width / 2);
            var centerY = bRect.top + (bRect.height / 2);

            if(xy.clientX > centerX) {
                // Right side
                resize.direction = xy.clientY > centerY ? DIRECTION.BOTTOMRIGHT : DIRECTION.TOPRIGHT;
            } else {
                // Left side
                resize.direction = xy.clientY > centerY ? DIRECTION.BOTTOMLEFT : DIRECTION.TOPLEFT;
            }
        }

        function onMove(e) {
            if (!isDragging && !isResizing) return;

            e.preventDefault();

            if(isDragging) {
                onDrag(e);
            } else {
                onResize(e);
            }
        }

        function onDrag(e) {
            var xy = getClientXY(e);

            // The top left of the shape should simply be positioned
            // (-drag.x, -drag.y) from the current mouse position
            // However, it should not be possible to drag it entirely out of the screen.
            // Partially is allowed, but we require a set amount of pixels to be visible.
            var bRect = drag.element.getBoundingClientRect();

            // If the shape is smaller than the minimum amount of pixels
            // we want on screen, use its width / height instead, otherwise the
            // shape can still be moved entirely off screen.
            var minWidthPx = Math.min(bRect.width, MIN_PIXELS_ON_SCREEN);
            var minHeightPx = Math.min(bRect.height, MIN_PIXELS_ON_SCREEN);

            var minLeft = -1 * (bRect.width - minWidthPx) / window.innerWidth;
            var maxLeft = (window.innerWidth - minWidthPx) / window.innerWidth;

            var minTop = -1 * (bRect.height - minHeightPx) / window.innerHeight;
            var maxTop =
                (window.innerHeight - minHeightPx) / window.innerHeight;

            var left = Math.max(
                minLeft,
                Math.min(maxLeft, xy.clientX / window.innerWidth - drag.x)
            );
            var top = Math.max(
                minTop,
                Math.min(maxTop, xy.clientY / window.innerHeight - drag.y)
            );

            drag.element.style.left = left * 100 + "%";
            drag.element.style.top = top * 100 + "%";
        }

        function onResize(e) {
            var xy = getClientXY(e);

            // We simply change the current width / height based on the distance
            // traveled with the mouse from the start coordinates
            var dx = xy.clientX - resize.x;
            var dy = xy.clientY - resize.y;

            var dx_f = resize.direction === DIRECTION.TOPLEFT || resize.direction === DIRECTION.BOTTOMLEFT ? -1 : 1;
            var dy_f = resize.direction === DIRECTION.TOPLEFT || resize.direction === DIRECTION.TOPRIGHT ? -1 : 1;

            var dx_vw = (dx / window.innerWidth) * 100 * dx_f;
            var dy_vh = (dy / window.innerHeight) * 100 * dy_f;

            resize.element.style.width = resize.width + dx_vw + "vw";
            resize.element.style.height = resize.height + dy_vh + "vh";

            var bRect = resize.element.getBoundingClientRect();

            // Depending on the direction of resize, we have to adjust top and left
            switch(resize.direction) {
                case DIRECTION.BOTTOMRIGHT:
                    // Resizing towards bottom-right is the "standard" resize,
                    // whereas top-left remains fixed, so we are done.
                    break;
                case DIRECTION.BOTTOMLEFT:
                    // When resizing towards the bottomleft the left should move leftwards
                    // the same amount as the width has changed
                    resize.element.style.left = resize.left - dx_vw + "%";
                    break;
                case DIRECTION.TOPRIGHT:
                    // When resizing towards the topright, the top should move upwards
                    // with the same amount as the height has changed.
                    resize.element.style.top = resize.top - dy_vh + "%";
                    break;
                case DIRECTION.TOPLEFT:
                    // When resizing towards the topleft, both top and left should move upwards
                    // and left, with the same amount as the height and width have changed, respectively.
                    resize.element.style.top = resize.top - dy_vh + "%";
                    resize.element.style.left = resize.left - dx_vw + "%";
                    break;
            }
        }

        function getClientXY(event) {
            var clientX, clientY;
            // clientX / clientY are in different properties of the event object
            // depending on if this is a Touch Event or not.
            // Note, IE does not know TouchEvent, we are not going to add support for whatever
            // they use instead.
            if (typeof TouchEvent !== "undefined" && event instanceof TouchEvent) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else if (event instanceof MouseEvent) {
                clientX = event.clientX;
                clientY = event.clientY;
            } else {
                throw new Error(
                    "getClientXY: event is neither TouchEvent nor MouseEvent!"
                );
            }

            return {
                clientX: clientX,
                clientY: clientY
            };
        }

        // Only register and deregister are exposed.
        // The service manages everything else.
        return {
            register: register,
            deregister: deregister
        };
    }]);

    app.directive("moveAndResize", ["moveAndResizeService", function(service) {
        return {
            restrict: "A",
            link: function($scope, $element, attrs) {
                var element = $element[0];
                service.register(element);

                $scope.$on('$destroy', function() {
                    service.deregister(element);
                });
            }
        }
    }]);
})();
</script>
</body>

</html>